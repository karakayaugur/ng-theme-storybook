{"ast":null,"code":"import { mapValues } from \"./chunk-KHNISLMN.js\";\nimport { isPlainObject } from \"./chunk-FSBVR7H5.js\";\nimport { __commonJS, __name, __toESM } from \"./chunk-MM7DTO55.js\";\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar require_dist = __commonJS({\n  \"../node_modules/jsdoc-type-pratt-parser/dist/index.js\"(exports, module) {\n    (function (global, factory) {\n      typeof exports === \"object\" && typeof module !== \"undefined\" ? factory(exports) : typeof define === \"function\" && define.amd ? define([\"exports\"], factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, factory(global.jtpp = {}));\n    })(exports, function (exports2) {\n      \"use strict\";\n\n      function tokenToString(token) {\n        if (token.text !== void 0 && token.text !== \"\") {\n          return `'${token.type}' with value '${token.text}'`;\n        } else {\n          return `'${token.type}'`;\n        }\n      }\n      __name(tokenToString, \"tokenToString\");\n      const _NoParsletFoundError = class _NoParsletFoundError extends Error {\n        constructor(token) {\n          super(`No parslet found for token: ${tokenToString(token)}`);\n          this.token = token;\n          Object.setPrototypeOf(this, _NoParsletFoundError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n      __name(_NoParsletFoundError, \"NoParsletFoundError\");\n      let NoParsletFoundError = _NoParsletFoundError;\n      const _EarlyEndOfParseError = class _EarlyEndOfParseError extends Error {\n        constructor(token) {\n          super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n          this.token = token;\n          Object.setPrototypeOf(this, _EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n      __name(_EarlyEndOfParseError, \"EarlyEndOfParseError\");\n      let EarlyEndOfParseError = _EarlyEndOfParseError;\n      const _UnexpectedTypeError = class _UnexpectedTypeError extends Error {\n        constructor(result, message) {\n          let error = `Unexpected type: '${result.type}'.`;\n          if (message !== void 0) {\n            error += ` Message: ${message}`;\n          }\n          super(error);\n          Object.setPrototypeOf(this, _UnexpectedTypeError.prototype);\n        }\n      };\n      __name(_UnexpectedTypeError, \"UnexpectedTypeError\");\n      let UnexpectedTypeError = _UnexpectedTypeError;\n      function makePunctuationRule(type) {\n        return text => {\n          if (text.startsWith(type)) {\n            return {\n              type,\n              text: type\n            };\n          } else {\n            return null;\n          }\n        };\n      }\n      __name(makePunctuationRule, \"makePunctuationRule\");\n      function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== \"'\" && mark !== '\"') {\n          return null;\n        }\n        while (position < text.length) {\n          position++;\n          char = text[position];\n          if (!escaped && char === mark) {\n            position++;\n            break;\n          }\n          escaped = !escaped && char === \"\\\\\";\n        }\n        if (char !== mark) {\n          throw new Error(\"Unterminated String\");\n        }\n        return text.slice(0, position);\n      }\n      __name(getQuoted, \"getQuoted\");\n      const identifierStartRegex = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      const identifierContinueRegex = new RegExp(\"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n          return null;\n        }\n        let position = 1;\n        do {\n          char = text[position];\n          if (!identifierContinueRegex.test(char)) {\n            break;\n          }\n          position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n      }\n      __name(getIdentifier, \"getIdentifier\");\n      const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n      function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n      }\n      __name(getNumber, \"getNumber\");\n      const identifierRule = /* @__PURE__ */__name(text => {\n        const value = getIdentifier(text);\n        if (value == null) {\n          return null;\n        }\n        return {\n          type: \"Identifier\",\n          text: value\n        };\n      }, \"identifierRule\");\n      function makeKeyWordRule(type) {\n        return text => {\n          if (!text.startsWith(type)) {\n            return null;\n          }\n          const prepends = text[type.length];\n          if (prepends !== void 0 && identifierContinueRegex.test(prepends)) {\n            return null;\n          }\n          return {\n            type,\n            text: type\n          };\n        };\n      }\n      __name(makeKeyWordRule, \"makeKeyWordRule\");\n      const stringValueRule = /* @__PURE__ */__name(text => {\n        const value = getQuoted(text);\n        if (value == null) {\n          return null;\n        }\n        return {\n          type: \"StringValue\",\n          text: value\n        };\n      }, \"stringValueRule\");\n      const eofRule = /* @__PURE__ */__name(text => {\n        if (text.length > 0) {\n          return null;\n        }\n        return {\n          type: \"EOF\",\n          text: \"\"\n        };\n      }, \"eofRule\");\n      const numberRule = /* @__PURE__ */__name(text => {\n        const value = getNumber(text);\n        if (value === null) {\n          return null;\n        }\n        return {\n          type: \"Number\",\n          text: value\n        };\n      }, \"numberRule\");\n      const rules = [eofRule, makePunctuationRule(\"=>\"), makePunctuationRule(\"(\"), makePunctuationRule(\")\"), makePunctuationRule(\"{\"), makePunctuationRule(\"}\"), makePunctuationRule(\"[\"), makePunctuationRule(\"]\"), makePunctuationRule(\"|\"), makePunctuationRule(\"&\"), makePunctuationRule(\"<\"), makePunctuationRule(\">\"), makePunctuationRule(\",\"), makePunctuationRule(\";\"), makePunctuationRule(\"*\"), makePunctuationRule(\"?\"), makePunctuationRule(\"!\"), makePunctuationRule(\"=\"), makePunctuationRule(\":\"), makePunctuationRule(\"...\"), makePunctuationRule(\".\"), makePunctuationRule(\"#\"), makePunctuationRule(\"~\"), makePunctuationRule(\"/\"), makePunctuationRule(\"@\"), makeKeyWordRule(\"undefined\"), makeKeyWordRule(\"null\"), makeKeyWordRule(\"function\"), makeKeyWordRule(\"this\"), makeKeyWordRule(\"new\"), makeKeyWordRule(\"module\"), makeKeyWordRule(\"event\"), makeKeyWordRule(\"extends\"), makeKeyWordRule(\"external\"), makeKeyWordRule(\"infer\"), makeKeyWordRule(\"typeof\"), makeKeyWordRule(\"keyof\"), makeKeyWordRule(\"readonly\"), makeKeyWordRule(\"import\"), makeKeyWordRule(\"is\"), makeKeyWordRule(\"in\"), makeKeyWordRule(\"asserts\"), numberRule, identifierRule, stringValueRule];\n      const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n      const _Lexer = class _Lexer {\n        static create(text) {\n          const current = this.read(text);\n          text = current.text;\n          const next = this.read(text);\n          text = next.text;\n          return new _Lexer(text, void 0, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n          this.text = \"\";\n          this.text = text;\n          this.previous = previous;\n          this.current = current;\n          this.next = next;\n        }\n        static read(text, startOfLine = false) {\n          startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n          text = text.trim();\n          for (const rule of rules) {\n            const partial = rule(text);\n            if (partial !== null) {\n              const token = Object.assign(Object.assign({}, partial), {\n                startOfLine\n              });\n              text = text.slice(token.text.length);\n              return {\n                text,\n                token\n              };\n            }\n          }\n          throw new Error(\"Unexpected Token \" + text);\n        }\n        advance() {\n          const next = _Lexer.read(this.text);\n          return new _Lexer(next.text, this.current, this.next, next.token);\n        }\n      };\n      __name(_Lexer, \"Lexer\");\n      let Lexer = _Lexer;\n      function assertRootResult(result) {\n        if (result === void 0) {\n          throw new Error(\"Unexpected undefined\");\n        }\n        if (result.type === \"JsdocTypeKeyValue\" || result.type === \"JsdocTypeParameterList\" || result.type === \"JsdocTypeProperty\" || result.type === \"JsdocTypeReadonlyProperty\" || result.type === \"JsdocTypeObjectField\" || result.type === \"JsdocTypeJsdocObjectField\" || result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\" || result.type === \"JsdocTypeTypeParameter\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertRootResult, \"assertRootResult\");\n      function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === \"JsdocTypeKeyValue\") {\n          return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n      }\n      __name(assertPlainKeyValueOrRootResult, \"assertPlainKeyValueOrRootResult\");\n      function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === \"JsdocTypeName\") {\n          return result;\n        }\n        return assertPlainKeyValueResult(result);\n      }\n      __name(assertPlainKeyValueOrNameResult, \"assertPlainKeyValueOrNameResult\");\n      function assertPlainKeyValueResult(result) {\n        if (result.type !== \"JsdocTypeKeyValue\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertPlainKeyValueResult, \"assertPlainKeyValueResult\");\n      function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === \"JsdocTypeVariadic\") {\n          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === \"JsdocTypeName\") {\n            return result;\n          }\n          throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== \"JsdocTypeNumber\" && result.type !== \"JsdocTypeName\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertNumberOrVariadicNameResult, \"assertNumberOrVariadicNameResult\");\n      function assertArrayOrTupleResult(result) {\n        if (result.type === \"JsdocTypeTuple\") {\n          return result;\n        }\n        if (result.type === \"JsdocTypeGeneric\" && result.meta.brackets === \"square\") {\n          return result;\n        }\n        throw new UnexpectedTypeError(result);\n      }\n      __name(assertArrayOrTupleResult, \"assertArrayOrTupleResult\");\n      function isSquaredProperty(result) {\n        return result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\";\n      }\n      __name(isSquaredProperty, \"isSquaredProperty\");\n      var Precedence;\n      (function (Precedence2) {\n        Precedence2[Precedence2[\"ALL\"] = 0] = \"ALL\";\n        Precedence2[Precedence2[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence2[Precedence2[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence2[Precedence2[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence2[Precedence2[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence2[Precedence2[\"UNION\"] = 5] = \"UNION\";\n        Precedence2[Precedence2[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence2[Precedence2[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence2[Precedence2[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence2[Precedence2[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence2[Precedence2[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence2[Precedence2[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence2[Precedence2[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence2[Precedence2[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence2[Precedence2[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence2[Precedence2[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence2[Precedence2[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence2[Precedence2[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence2[Precedence2[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence2[Precedence2[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence2[Precedence2[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n      })(Precedence || (Precedence = {}));\n      const _Parser = class _Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n          this.grammar = grammar;\n          if (typeof textOrLexer === \"string\") {\n            this._lexer = Lexer.create(textOrLexer);\n          } else {\n            this._lexer = textOrLexer;\n          }\n          this.baseParser = baseParser;\n        }\n        get lexer() {\n          return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n          const result = this.parseType(Precedence.ALL);\n          if (this.lexer.current.type !== \"EOF\") {\n            throw new EarlyEndOfParseError(this.lexer.current);\n          }\n          return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n          return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n          const result = this.tryParslets(null, precedence);\n          if (result === null) {\n            throw new NoParsletFoundError(this.lexer.current);\n          }\n          return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n          let result = this.tryParslets(left, precedence);\n          while (result !== null) {\n            left = result;\n            result = this.tryParslets(left, precedence);\n          }\n          return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n          for (const parslet of this.grammar) {\n            const result = parslet(this, precedence, left);\n            if (result !== null) {\n              return result;\n            }\n          }\n          return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n          if (!Array.isArray(types)) {\n            types = [types];\n          }\n          if (types.includes(this.lexer.current.type)) {\n            this._lexer = this.lexer.advance();\n            return true;\n          } else {\n            return false;\n          }\n        }\n        acceptLexerState(parser) {\n          this._lexer = parser.lexer;\n        }\n      };\n      __name(_Parser, \"Parser\");\n      let Parser = _Parser;\n      function isQuestionMarkUnknownType(next) {\n        return next === \"}\" || next === \"EOF\" || next === \"|\" || next === \",\" || next === \")\" || next === \">\";\n      }\n      __name(isQuestionMarkUnknownType, \"isQuestionMarkUnknownType\");\n      const nullableParslet = /* @__PURE__ */__name((parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = left == null && type === \"?\" && !isQuestionMarkUnknownType(next) || left != null && type === \"?\";\n        if (!accept) {\n          return null;\n        }\n        parser.consume(\"?\");\n        if (left == null) {\n          return {\n            type: \"JsdocTypeNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        } else {\n          return {\n            type: \"JsdocTypeNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }\n      }, \"nullableParslet\");\n      function composeParslet(options) {\n        const parslet = /* @__PURE__ */__name((parser, curPrecedence, left) => {\n          const type = parser.lexer.current.type;\n          const next = parser.lexer.next.type;\n          if (left === null) {\n            if (\"parsePrefix\" in options) {\n              if (options.accept(type, next)) {\n                return options.parsePrefix(parser);\n              }\n            }\n          } else {\n            if (\"parseInfix\" in options) {\n              if (options.precedence > curPrecedence && options.accept(type, next)) {\n                return options.parseInfix(parser, left);\n              }\n            }\n          }\n          return null;\n        }, \"parslet\");\n        Object.defineProperty(parslet, \"name\", {\n          value: options.name\n        });\n        return parslet;\n      }\n      __name(composeParslet, \"composeParslet\");\n      const optionalParslet = composeParslet({\n        name: \"optionalParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"=\", \"accept\"),\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"=\");\n          return {\n            type: \"JsdocTypeOptional\",\n            element: parser.parseType(Precedence.OPTIONAL),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        }, \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          parser.consume(\"=\");\n          return {\n            type: \"JsdocTypeOptional\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }, \"parseInfix\")\n      });\n      const numberParslet = composeParslet({\n        name: \"numberParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"Number\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          const value = parseFloat(parser.lexer.current.text);\n          parser.consume(\"Number\");\n          return {\n            type: \"JsdocTypeNumber\",\n            value\n          };\n        }, \"parsePrefix\")\n      });\n      const parenthesisParslet = composeParslet({\n        name: \"parenthesisParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"(\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"(\");\n          if (parser.consume(\")\")) {\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: []\n            };\n          }\n          const result = parser.parseIntermediateType(Precedence.ALL);\n          if (!parser.consume(\")\")) {\n            throw new Error(\"Unterminated parenthesis\");\n          }\n          if (result.type === \"JsdocTypeParameterList\") {\n            return result;\n          } else if (result.type === \"JsdocTypeKeyValue\") {\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: [result]\n            };\n          }\n          return {\n            type: \"JsdocTypeParenthesis\",\n            element: assertRootResult(result)\n          };\n        }, \"parsePrefix\")\n      });\n      const specialTypesParslet = composeParslet({\n        name: \"specialTypesParslet\",\n        accept: /* @__PURE__ */__name((type, next) => type === \"?\" && isQuestionMarkUnknownType(next) || type === \"null\" || type === \"undefined\" || type === \"*\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          if (parser.consume(\"null\")) {\n            return {\n              type: \"JsdocTypeNull\"\n            };\n          }\n          if (parser.consume(\"undefined\")) {\n            return {\n              type: \"JsdocTypeUndefined\"\n            };\n          }\n          if (parser.consume(\"*\")) {\n            return {\n              type: \"JsdocTypeAny\"\n            };\n          }\n          if (parser.consume(\"?\")) {\n            return {\n              type: \"JsdocTypeUnknown\"\n            };\n          }\n          throw new Error(\"Unacceptable token: \" + parser.lexer.current.text);\n        }, \"parsePrefix\")\n      });\n      const notNullableParslet = composeParslet({\n        name: \"notNullableParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"!\", \"accept\"),\n        precedence: Precedence.NULLABLE,\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"!\");\n          return {\n            type: \"JsdocTypeNotNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        }, \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          parser.consume(\"!\");\n          return {\n            type: \"JsdocTypeNotNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }, \"parseInfix\")\n      });\n      function createParameterListParslet({\n        allowTrailingComma\n      }) {\n        return composeParslet({\n          name: \"parameterListParslet\",\n          accept: /* @__PURE__ */__name(type => type === \",\", \"accept\"),\n          precedence: Precedence.PARAMETER_LIST,\n          parseInfix: /* @__PURE__ */__name((parser, left) => {\n            const elements = [assertPlainKeyValueOrRootResult(left)];\n            parser.consume(\",\");\n            do {\n              try {\n                const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                elements.push(assertPlainKeyValueOrRootResult(next));\n              } catch (e) {\n                if (e instanceof NoParsletFoundError) {\n                  break;\n                } else {\n                  throw e;\n                }\n              }\n            } while (parser.consume(\",\"));\n            if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === \"JsdocTypeVariadic\")) {\n              throw new Error(\"Only the last parameter may be a rest parameter\");\n            }\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements\n            };\n          }, \"parseInfix\")\n        });\n      }\n      __name(createParameterListParslet, \"createParameterListParslet\");\n      const genericParslet = composeParslet({\n        name: \"genericParslet\",\n        accept: /* @__PURE__ */__name((type, next) => type === \"<\" || type === \".\" && next === \"<\", \"accept\"),\n        precedence: Precedence.GENERIC,\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          const dot = parser.consume(\".\");\n          parser.consume(\"<\");\n          const objects = [];\n          let infer = false;\n          if (parser.consume(\"infer\")) {\n            infer = true;\n            const left2 = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left2.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(left2, \"A typescript asserts always has to have a name on the left side.\");\n            }\n            objects.push(left2);\n          } else {\n            do {\n              objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            } while (parser.consume(\",\"));\n          }\n          if (!parser.consume(\">\")) {\n            throw new Error(\"Unterminated generic parameter list\");\n          }\n          return Object.assign(Object.assign({\n            type: \"JsdocTypeGeneric\",\n            left: assertRootResult(left),\n            elements: objects\n          }, infer ? {\n            infer: true\n          } : {}), {\n            meta: {\n              brackets: \"angle\",\n              dot\n            }\n          });\n        }, \"parseInfix\")\n      });\n      const unionParslet = composeParslet({\n        name: \"unionParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"|\", \"accept\"),\n        precedence: Precedence.UNION,\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          parser.consume(\"|\");\n          const elements = [];\n          do {\n            elements.push(parser.parseType(Precedence.UNION));\n          } while (parser.consume(\"|\"));\n          return {\n            type: \"JsdocTypeUnion\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }, \"parseInfix\")\n      });\n      const baseGrammar = [nullableParslet, optionalParslet, numberParslet, parenthesisParslet, specialTypesParslet, notNullableParslet, createParameterListParslet({\n        allowTrailingComma: true\n      }), genericParslet, unionParslet, optionalParslet];\n      function createNamePathParslet({\n        allowSquareBracketsOnAnyType,\n        allowJsdocNamePaths,\n        pathGrammar: pathGrammar2\n      }) {\n        return /* @__PURE__ */__name(function namePathParslet(parser, precedence, left) {\n          if (left == null || precedence >= Precedence.NAME_PATH) {\n            return null;\n          }\n          const type = parser.lexer.current.type;\n          const next = parser.lexer.next.type;\n          const accept = type === \".\" && next !== \"<\" || type === \"[\" && (allowSquareBracketsOnAnyType || left.type === \"JsdocTypeName\") || allowJsdocNamePaths && (type === \"~\" || type === \"#\");\n          if (!accept) {\n            return null;\n          }\n          let pathType;\n          let brackets = false;\n          if (parser.consume(\".\")) {\n            pathType = \"property\";\n          } else if (parser.consume(\"[\")) {\n            pathType = \"property-brackets\";\n            brackets = true;\n          } else if (parser.consume(\"~\")) {\n            pathType = \"inner\";\n          } else {\n            parser.consume(\"#\");\n            pathType = \"instance\";\n          }\n          const pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser;\n          const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n          parser.acceptLexerState(pathParser);\n          let right;\n          switch (parsed.type) {\n            case \"JsdocTypeName\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeNumber\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value.toString(10),\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeStringValue\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: parsed.meta.quote\n                }\n              };\n              break;\n            case \"JsdocTypeSpecialNamePath\":\n              if (parsed.specialType === \"event\") {\n                right = parsed;\n              } else {\n                throw new UnexpectedTypeError(parsed, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n              }\n              break;\n            default:\n              throw new UnexpectedTypeError(parsed, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n          }\n          if (brackets && !parser.consume(\"]\")) {\n            const token = parser.lexer.current;\n            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);\n          }\n          return {\n            type: \"JsdocTypeNamePath\",\n            left: assertRootResult(left),\n            right,\n            pathType\n          };\n        }, \"namePathParslet\");\n      }\n      __name(createNamePathParslet, \"createNamePathParslet\");\n      function createNameParslet({\n        allowedAdditionalTokens\n      }) {\n        return composeParslet({\n          name: \"nameParslet\",\n          accept: /* @__PURE__ */__name(type => type === \"Identifier\" || type === \"this\" || type === \"new\" || allowedAdditionalTokens.includes(type), \"accept\"),\n          parsePrefix: /* @__PURE__ */__name(parser => {\n            const {\n              type,\n              text\n            } = parser.lexer.current;\n            parser.consume(type);\n            return {\n              type: \"JsdocTypeName\",\n              value: text\n            };\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createNameParslet, \"createNameParslet\");\n      const stringValueParslet = composeParslet({\n        name: \"stringValueParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"StringValue\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          const text = parser.lexer.current.text;\n          parser.consume(\"StringValue\");\n          return {\n            type: \"JsdocTypeStringValue\",\n            value: text.slice(1, -1),\n            meta: {\n              quote: text[0] === \"'\" ? \"single\" : \"double\"\n            }\n          };\n        }, \"parsePrefix\")\n      });\n      function createSpecialNamePathParslet({\n        pathGrammar: pathGrammar2,\n        allowedTypes\n      }) {\n        return composeParslet({\n          name: \"specialNamePathParslet\",\n          accept: /* @__PURE__ */__name(type => allowedTypes.includes(type), \"accept\"),\n          parsePrefix: /* @__PURE__ */__name(parser => {\n            const type = parser.lexer.current.type;\n            parser.consume(type);\n            if (!parser.consume(\":\")) {\n              return {\n                type: \"JsdocTypeName\",\n                value: type\n              };\n            }\n            let result;\n            let token = parser.lexer.current;\n            if (parser.consume(\"StringValue\")) {\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value: token.text.slice(1, -1),\n                specialType: type,\n                meta: {\n                  quote: token.text[0] === \"'\" ? \"single\" : \"double\"\n                }\n              };\n            } else {\n              let value = \"\";\n              const allowed = [\"Identifier\", \"@\", \"/\"];\n              while (allowed.some(type2 => parser.consume(type2))) {\n                value += token.text;\n                token = parser.lexer.current;\n              }\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value,\n                specialType: type,\n                meta: {\n                  quote: void 0\n                }\n              };\n            }\n            const moduleParser = new Parser(pathGrammar2, parser.lexer, parser);\n            const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n            parser.acceptLexerState(moduleParser);\n            return assertRootResult(moduleResult);\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createSpecialNamePathParslet, \"createSpecialNamePathParslet\");\n      const basePathGrammar = [createNameParslet({\n        allowedAdditionalTokens: [\"external\", \"module\"]\n      }), stringValueParslet, numberParslet, createNamePathParslet({\n        allowSquareBracketsOnAnyType: false,\n        allowJsdocNamePaths: true,\n        pathGrammar: null\n      })];\n      const pathGrammar = [...basePathGrammar, createSpecialNamePathParslet({\n        allowedTypes: [\"event\"],\n        pathGrammar: basePathGrammar\n      })];\n      function getParameters(value) {\n        let parameters;\n        if (value.type === \"JsdocTypeParameterList\") {\n          parameters = value.elements;\n        } else if (value.type === \"JsdocTypeParenthesis\") {\n          parameters = [value.element];\n        } else {\n          throw new UnexpectedTypeError(value);\n        }\n        return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n      }\n      __name(getParameters, \"getParameters\");\n      function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some(p => p.type === \"JsdocTypeKeyValue\")) {\n          throw new Error(\"No parameter should be named\");\n        }\n        return parameters;\n      }\n      __name(getUnnamedParameters, \"getUnnamedParameters\");\n      function createFunctionParslet({\n        allowNamedParameters,\n        allowNoReturnType,\n        allowWithoutParenthesis,\n        allowNewAsFunctionKeyword\n      }) {\n        return composeParslet({\n          name: \"functionParslet\",\n          accept: /* @__PURE__ */__name((type, next) => type === \"function\" || allowNewAsFunctionKeyword && type === \"new\" && next === \"(\", \"accept\"),\n          parsePrefix: /* @__PURE__ */__name(parser => {\n            const newKeyword = parser.consume(\"new\");\n            parser.consume(\"function\");\n            const hasParenthesis = parser.lexer.current.type === \"(\";\n            if (!hasParenthesis) {\n              if (!allowWithoutParenthesis) {\n                throw new Error(\"function is missing parameter list\");\n              }\n              return {\n                type: \"JsdocTypeName\",\n                value: \"function\"\n              };\n            }\n            let result = {\n              type: \"JsdocTypeFunction\",\n              parameters: [],\n              arrow: false,\n              constructor: newKeyword,\n              parenthesis: hasParenthesis\n            };\n            const value = parser.parseIntermediateType(Precedence.FUNCTION);\n            if (allowNamedParameters === void 0) {\n              result.parameters = getUnnamedParameters(value);\n            } else if (newKeyword && value.type === \"JsdocTypeFunction\" && value.arrow) {\n              result = value;\n              result.constructor = true;\n              return result;\n            } else {\n              result.parameters = getParameters(value);\n              for (const p of result.parameters) {\n                if (p.type === \"JsdocTypeKeyValue\" && !allowNamedParameters.includes(p.key)) {\n                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(\", \")} but got ${p.type}`);\n                }\n              }\n            }\n            if (parser.consume(\":\")) {\n              result.returnType = parser.parseType(Precedence.PREFIX);\n            } else {\n              if (!allowNoReturnType) {\n                throw new Error(\"function is missing return type\");\n              }\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createFunctionParslet, \"createFunctionParslet\");\n      function createVariadicParslet({\n        allowPostfix,\n        allowEnclosingBrackets\n      }) {\n        return composeParslet({\n          name: \"variadicParslet\",\n          accept: /* @__PURE__ */__name(type => type === \"...\", \"accept\"),\n          precedence: Precedence.PREFIX,\n          parsePrefix: /* @__PURE__ */__name(parser => {\n            parser.consume(\"...\");\n            const brackets = allowEnclosingBrackets && parser.consume(\"[\");\n            try {\n              const element = parser.parseType(Precedence.PREFIX);\n              if (brackets && !parser.consume(\"]\")) {\n                throw new Error(\"Unterminated variadic type. Missing ']'\");\n              }\n              return {\n                type: \"JsdocTypeVariadic\",\n                element: assertRootResult(element),\n                meta: {\n                  position: \"prefix\",\n                  squareBrackets: brackets\n                }\n              };\n            } catch (e) {\n              if (e instanceof NoParsletFoundError) {\n                if (brackets) {\n                  throw new Error(\"Empty square brackets for variadic are not allowed.\");\n                }\n                return {\n                  type: \"JsdocTypeVariadic\",\n                  meta: {\n                    position: void 0,\n                    squareBrackets: false\n                  }\n                };\n              } else {\n                throw e;\n              }\n            }\n          }, \"parsePrefix\"),\n          parseInfix: allowPostfix ? (parser, left) => {\n            parser.consume(\"...\");\n            return {\n              type: \"JsdocTypeVariadic\",\n              element: assertRootResult(left),\n              meta: {\n                position: \"suffix\",\n                squareBrackets: false\n              }\n            };\n          } : void 0\n        });\n      }\n      __name(createVariadicParslet, \"createVariadicParslet\");\n      const symbolParslet = composeParslet({\n        name: \"symbolParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"(\", \"accept\"),\n        precedence: Precedence.SYMBOL,\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          if (left.type !== \"JsdocTypeName\") {\n            throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n          }\n          parser.consume(\"(\");\n          const result = {\n            type: \"JsdocTypeSymbol\",\n            value: left.value\n          };\n          if (!parser.consume(\")\")) {\n            const next = parser.parseIntermediateType(Precedence.SYMBOL);\n            result.element = assertNumberOrVariadicNameResult(next);\n            if (!parser.consume(\")\")) {\n              throw new Error(\"Symbol does not end after value\");\n            }\n          }\n          return result;\n        }, \"parseInfix\")\n      });\n      const arrayBracketsParslet = composeParslet({\n        name: \"arrayBracketsParslet\",\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: /* @__PURE__ */__name((type, next) => type === \"[\" && next === \"]\", \"accept\"),\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          parser.consume(\"[\");\n          parser.consume(\"]\");\n          return {\n            type: \"JsdocTypeGeneric\",\n            left: {\n              type: \"JsdocTypeName\",\n              value: \"Array\"\n            },\n            elements: [assertRootResult(left)],\n            meta: {\n              brackets: \"square\",\n              dot: false\n            }\n          };\n        }, \"parseInfix\")\n      });\n      function createObjectParslet({\n        objectFieldGrammar: objectFieldGrammar2,\n        allowKeyTypes\n      }) {\n        return composeParslet({\n          name: \"objectParslet\",\n          accept: /* @__PURE__ */__name(type => type === \"{\", \"accept\"),\n          parsePrefix: /* @__PURE__ */__name(parser => {\n            parser.consume(\"{\");\n            const result = {\n              type: \"JsdocTypeObject\",\n              meta: {\n                separator: \"comma\"\n              },\n              elements: []\n            };\n            if (!parser.consume(\"}\")) {\n              let separator;\n              const fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);\n              while (true) {\n                fieldParser.acceptLexerState(parser);\n                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                parser.acceptLexerState(fieldParser);\n                if (field === void 0 && allowKeyTypes) {\n                  field = parser.parseIntermediateType(Precedence.OBJECT);\n                }\n                let optional = false;\n                if (field.type === \"JsdocTypeNullable\") {\n                  optional = true;\n                  field = field.element;\n                }\n                if (field.type === \"JsdocTypeNumber\" || field.type === \"JsdocTypeName\" || field.type === \"JsdocTypeStringValue\") {\n                  let quote2;\n                  if (field.type === \"JsdocTypeStringValue\") {\n                    quote2 = field.meta.quote;\n                  }\n                  result.elements.push({\n                    type: \"JsdocTypeObjectField\",\n                    key: field.value.toString(),\n                    right: void 0,\n                    optional,\n                    readonly: false,\n                    meta: {\n                      quote: quote2\n                    }\n                  });\n                } else if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") {\n                  result.elements.push(field);\n                } else {\n                  throw new UnexpectedTypeError(field);\n                }\n                if (parser.lexer.current.startOfLine) {\n                  separator = \"linebreak\";\n                  parser.consume(\",\") || parser.consume(\";\");\n                } else if (parser.consume(\",\")) {\n                  separator = \"comma\";\n                } else if (parser.consume(\";\")) {\n                  separator = \"semicolon\";\n                } else {\n                  break;\n                }\n                const type = parser.lexer.current.type;\n                if (type === \"}\") {\n                  break;\n                }\n              }\n              result.meta.separator = separator !== null && separator !== void 0 ? separator : \"comma\";\n              if (separator === \"linebreak\") {\n                result.meta.propertyIndent = \"  \";\n              }\n              if (!parser.consume(\"}\")) {\n                throw new Error(\"Unterminated record type. Missing '}'\");\n              }\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createObjectParslet, \"createObjectParslet\");\n      function createObjectFieldParslet({\n        allowSquaredProperties,\n        allowKeyTypes,\n        allowReadonly,\n        allowOptional\n      }) {\n        return composeParslet({\n          name: \"objectFieldParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: /* @__PURE__ */__name(type => type === \":\", \"accept\"),\n          parseInfix: /* @__PURE__ */__name((parser, left) => {\n            var _a;\n            let optional = false;\n            let readonlyProperty = false;\n            if (allowOptional && left.type === \"JsdocTypeNullable\") {\n              optional = true;\n              left = left.element;\n            }\n            if (allowReadonly && left.type === \"JsdocTypeReadonlyProperty\") {\n              readonlyProperty = true;\n              left = left.element;\n            }\n            const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n            parentParser.acceptLexerState(parser);\n            if (left.type === \"JsdocTypeNumber\" || left.type === \"JsdocTypeName\" || left.type === \"JsdocTypeStringValue\" || isSquaredProperty(left)) {\n              if (isSquaredProperty(left) && !allowSquaredProperties) {\n                throw new UnexpectedTypeError(left);\n              }\n              parentParser.consume(\":\");\n              let quote2;\n              if (left.type === \"JsdocTypeStringValue\") {\n                quote2 = left.meta.quote;\n              }\n              const right = parentParser.parseType(Precedence.KEY_VALUE);\n              parser.acceptLexerState(parentParser);\n              return {\n                type: \"JsdocTypeObjectField\",\n                key: isSquaredProperty(left) ? left : left.value.toString(),\n                right,\n                optional,\n                readonly: readonlyProperty,\n                meta: {\n                  quote: quote2\n                }\n              };\n            } else {\n              if (!allowKeyTypes) {\n                throw new UnexpectedTypeError(left);\n              }\n              parentParser.consume(\":\");\n              const right = parentParser.parseType(Precedence.KEY_VALUE);\n              parser.acceptLexerState(parentParser);\n              return {\n                type: \"JsdocTypeJsdocObjectField\",\n                left: assertRootResult(left),\n                right\n              };\n            }\n          }, \"parseInfix\")\n        });\n      }\n      __name(createObjectFieldParslet, \"createObjectFieldParslet\");\n      function createKeyValueParslet({\n        allowOptional,\n        allowVariadic\n      }) {\n        return composeParslet({\n          name: \"keyValueParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: /* @__PURE__ */__name(type => type === \":\", \"accept\"),\n          parseInfix: /* @__PURE__ */__name((parser, left) => {\n            let optional = false;\n            let variadic = false;\n            if (allowOptional && left.type === \"JsdocTypeNullable\") {\n              optional = true;\n              left = left.element;\n            }\n            if (allowVariadic && left.type === \"JsdocTypeVariadic\" && left.element !== void 0) {\n              variadic = true;\n              left = left.element;\n            }\n            if (left.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(left);\n            }\n            parser.consume(\":\");\n            const right = parser.parseType(Precedence.KEY_VALUE);\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: left.value,\n              right,\n              optional,\n              variadic\n            };\n          }, \"parseInfix\")\n        });\n      }\n      __name(createKeyValueParslet, \"createKeyValueParslet\");\n      const jsdocBaseGrammar = [...baseGrammar, createFunctionParslet({\n        allowWithoutParenthesis: true,\n        allowNamedParameters: [\"this\", \"new\"],\n        allowNoReturnType: true,\n        allowNewAsFunctionKeyword: false\n      }), stringValueParslet, createSpecialNamePathParslet({\n        allowedTypes: [\"module\", \"external\", \"event\"],\n        pathGrammar\n      }), createVariadicParslet({\n        allowEnclosingBrackets: true,\n        allowPostfix: true\n      }), createNameParslet({\n        allowedAdditionalTokens: [\"keyof\"]\n      }), symbolParslet, arrayBracketsParslet, createNamePathParslet({\n        allowSquareBracketsOnAnyType: false,\n        allowJsdocNamePaths: true,\n        pathGrammar\n      })];\n      const jsdocGrammar = [...jsdocBaseGrammar, createObjectParslet({\n        // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n        // we leave out the object type deliberately\n        objectFieldGrammar: [createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"in\"]\n        }), createObjectFieldParslet({\n          allowSquaredProperties: false,\n          allowKeyTypes: true,\n          allowOptional: false,\n          allowReadonly: false\n        }), ...jsdocBaseGrammar],\n        allowKeyTypes: true\n      }), createKeyValueParslet({\n        allowOptional: true,\n        allowVariadic: true\n      })];\n      const typeOfParslet = composeParslet({\n        name: \"typeOfParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"typeof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"typeof\");\n          return {\n            type: \"JsdocTypeTypeof\",\n            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n          };\n        }, \"parsePrefix\")\n      });\n      const objectFieldGrammar$1 = [createNameParslet({\n        allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n      }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n        allowSquaredProperties: false,\n        allowKeyTypes: false,\n        allowOptional: false,\n        allowReadonly: false\n      })];\n      const closureGrammar = [...baseGrammar, createObjectParslet({\n        allowKeyTypes: false,\n        objectFieldGrammar: objectFieldGrammar$1\n      }), createNameParslet({\n        allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n      }), typeOfParslet, createFunctionParslet({\n        allowWithoutParenthesis: false,\n        allowNamedParameters: [\"this\", \"new\"],\n        allowNoReturnType: true,\n        allowNewAsFunctionKeyword: false\n      }), createVariadicParslet({\n        allowEnclosingBrackets: false,\n        allowPostfix: false\n      }),\n      // additional name parslet is needed for some special cases\n      createNameParslet({\n        allowedAdditionalTokens: [\"keyof\"]\n      }), createSpecialNamePathParslet({\n        allowedTypes: [\"module\"],\n        pathGrammar\n      }), createNamePathParslet({\n        allowSquareBracketsOnAnyType: false,\n        allowJsdocNamePaths: true,\n        pathGrammar\n      }), createKeyValueParslet({\n        allowOptional: false,\n        allowVariadic: false\n      }), symbolParslet];\n      const assertsParslet = composeParslet({\n        name: \"assertsParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"asserts\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"asserts\");\n          const left = parser.parseIntermediateType(Precedence.SYMBOL);\n          if (left.type !== \"JsdocTypeName\") {\n            throw new UnexpectedTypeError(left, \"A typescript asserts always has to have a name on the left side.\");\n          }\n          if (!parser.consume(\"is\")) {\n            return {\n              type: \"JsdocTypeAssertsPlain\",\n              element: left\n            };\n          }\n          return {\n            type: \"JsdocTypeAsserts\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }, \"parsePrefix\")\n      });\n      function createTupleParslet({\n        allowQuestionMark\n      }) {\n        return composeParslet({\n          name: \"tupleParslet\",\n          accept: /* @__PURE__ */__name(type => type === \"[\", \"accept\"),\n          parsePrefix: /* @__PURE__ */__name(parser => {\n            parser.consume(\"[\");\n            const result = {\n              type: \"JsdocTypeTuple\",\n              elements: []\n            };\n            if (parser.consume(\"]\")) {\n              return result;\n            }\n            const typeList = parser.parseIntermediateType(Precedence.ALL);\n            if (typeList.type === \"JsdocTypeParameterList\") {\n              if (typeList.elements[0].type === \"JsdocTypeKeyValue\") {\n                result.elements = typeList.elements.map(assertPlainKeyValueResult);\n              } else {\n                result.elements = typeList.elements.map(assertRootResult);\n              }\n            } else {\n              if (typeList.type === \"JsdocTypeKeyValue\") {\n                result.elements = [assertPlainKeyValueResult(typeList)];\n              } else {\n                result.elements = [assertRootResult(typeList)];\n              }\n            }\n            if (!parser.consume(\"]\")) {\n              throw new Error(\"Unterminated '['\");\n            }\n            if (result.elements.some(e => e.type === \"JsdocTypeUnknown\")) {\n              throw new Error(\"Question mark in tuple not allowed\");\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createTupleParslet, \"createTupleParslet\");\n      const keyOfParslet = composeParslet({\n        name: \"keyOfParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"keyof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"keyof\");\n          return {\n            type: \"JsdocTypeKeyof\",\n            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n          };\n        }, \"parsePrefix\")\n      });\n      const importParslet = composeParslet({\n        name: \"importParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"import\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"import\");\n          if (!parser.consume(\"(\")) {\n            throw new Error(\"Missing parenthesis after import keyword\");\n          }\n          const path = parser.parseType(Precedence.PREFIX);\n          if (path.type !== \"JsdocTypeStringValue\") {\n            throw new Error(\"Only string values are allowed as paths for imports\");\n          }\n          if (!parser.consume(\")\")) {\n            throw new Error(\"Missing closing parenthesis after import keyword\");\n          }\n          return {\n            type: \"JsdocTypeImport\",\n            element: path\n          };\n        }, \"parsePrefix\")\n      });\n      const readonlyPropertyParslet = composeParslet({\n        name: \"readonlyPropertyParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"readonly\");\n          return {\n            type: \"JsdocTypeReadonlyProperty\",\n            element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n          };\n        }, \"parsePrefix\")\n      });\n      const arrowFunctionParslet = composeParslet({\n        name: \"arrowFunctionParslet\",\n        precedence: Precedence.ARROW,\n        accept: /* @__PURE__ */__name(type => type === \"=>\", \"accept\"),\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          parser.consume(\"=>\");\n          return {\n            type: \"JsdocTypeFunction\",\n            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n            arrow: true,\n            constructor: false,\n            parenthesis: true,\n            returnType: parser.parseType(Precedence.OBJECT)\n          };\n        }, \"parseInfix\")\n      });\n      const genericArrowFunctionParslet = composeParslet({\n        name: \"genericArrowFunctionParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"<\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          const typeParameters = [];\n          parser.consume(\"<\");\n          do {\n            let defaultValue;\n            let name = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (name.type === \"JsdocTypeOptional\") {\n              name = name.element;\n              defaultValue = parser.parseType(Precedence.SYMBOL);\n            }\n            if (name.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(name);\n            }\n            let constraint;\n            if (parser.consume(\"extends\")) {\n              constraint = parser.parseType(Precedence.SYMBOL);\n              if (constraint.type === \"JsdocTypeOptional\") {\n                constraint = constraint.element;\n                defaultValue = parser.parseType(Precedence.SYMBOL);\n              }\n            }\n            const typeParameter = {\n              type: \"JsdocTypeTypeParameter\",\n              name\n            };\n            if (constraint !== void 0) {\n              typeParameter.constraint = constraint;\n            }\n            if (defaultValue !== void 0) {\n              typeParameter.defaultValue = defaultValue;\n            }\n            typeParameters.push(typeParameter);\n            if (parser.consume(\">\")) {\n              break;\n            }\n          } while (parser.consume(\",\"));\n          const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n          functionBase.typeParameters = typeParameters;\n          return functionBase;\n        }, \"parsePrefix\")\n      });\n      const intersectionParslet = composeParslet({\n        name: \"intersectionParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"&\", \"accept\"),\n        precedence: Precedence.INTERSECTION,\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          parser.consume(\"&\");\n          const elements = [];\n          do {\n            elements.push(parser.parseType(Precedence.INTERSECTION));\n          } while (parser.consume(\"&\"));\n          return {\n            type: \"JsdocTypeIntersection\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }, \"parseInfix\")\n      });\n      const predicateParslet = composeParslet({\n        name: \"predicateParslet\",\n        precedence: Precedence.INFIX,\n        accept: /* @__PURE__ */__name(type => type === \"is\", \"accept\"),\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          if (left.type !== \"JsdocTypeName\") {\n            throw new UnexpectedTypeError(left, \"A typescript predicate always has to have a name on the left side.\");\n          }\n          parser.consume(\"is\");\n          return {\n            type: \"JsdocTypePredicate\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }, \"parseInfix\")\n      });\n      const objectSquaredPropertyParslet = composeParslet({\n        name: \"objectSquareBracketPropertyParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"[\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          if (parser.baseParser === void 0) {\n            throw new Error(\"Only allowed inside object grammar\");\n          }\n          parser.consume(\"[\");\n          const key = parser.lexer.current.text;\n          parser.consume(\"Identifier\");\n          let result;\n          if (parser.consume(\":\")) {\n            const parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser);\n            result = {\n              type: \"JsdocTypeIndexSignature\",\n              key,\n              right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n            };\n            parser.acceptLexerState(parentParser);\n          } else if (parser.consume(\"in\")) {\n            const parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser);\n            result = {\n              type: \"JsdocTypeMappedType\",\n              key,\n              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n            };\n            parser.acceptLexerState(parentParser);\n          } else {\n            throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n          }\n          if (!parser.consume(\"]\")) {\n            throw new Error(\"Unterminated square brackets\");\n          }\n          return result;\n        }, \"parsePrefix\")\n      });\n      const readonlyArrayParslet = composeParslet({\n        name: \"readonlyArrayParslet\",\n        accept: /* @__PURE__ */__name(type => type === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */__name(parser => {\n          parser.consume(\"readonly\");\n          return {\n            type: \"JsdocTypeReadonlyArray\",\n            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n          };\n        }, \"parsePrefix\")\n      });\n      const conditionalParslet = composeParslet({\n        name: \"conditionalParslet\",\n        precedence: Precedence.INFIX,\n        accept: /* @__PURE__ */__name(type => type === \"extends\", \"accept\"),\n        parseInfix: /* @__PURE__ */__name((parser, left) => {\n          parser.consume(\"extends\");\n          const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;\n          const trueType = parser.parseType(Precedence.INFIX);\n          parser.consume(\":\");\n          return {\n            type: \"JsdocTypeConditional\",\n            checksType: assertRootResult(left),\n            extendsType,\n            trueType,\n            falseType: parser.parseType(Precedence.INFIX)\n          };\n        }, \"parseInfix\")\n      });\n      const objectFieldGrammar = [readonlyPropertyParslet, createNameParslet({\n        allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n      }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n        allowSquaredProperties: true,\n        allowKeyTypes: false,\n        allowOptional: true,\n        allowReadonly: true\n      }), objectSquaredPropertyParslet];\n      const typescriptGrammar = [...baseGrammar, createObjectParslet({\n        allowKeyTypes: false,\n        objectFieldGrammar\n      }), readonlyArrayParslet, typeOfParslet, keyOfParslet, importParslet, stringValueParslet, createFunctionParslet({\n        allowWithoutParenthesis: true,\n        allowNoReturnType: false,\n        allowNamedParameters: [\"this\", \"new\", \"args\"],\n        allowNewAsFunctionKeyword: true\n      }), createTupleParslet({\n        allowQuestionMark: false\n      }), createVariadicParslet({\n        allowEnclosingBrackets: false,\n        allowPostfix: false\n      }), assertsParslet, conditionalParslet, createNameParslet({\n        allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n      }), createSpecialNamePathParslet({\n        allowedTypes: [\"module\"],\n        pathGrammar\n      }), arrayBracketsParslet, arrowFunctionParslet, genericArrowFunctionParslet, createNamePathParslet({\n        allowSquareBracketsOnAnyType: true,\n        allowJsdocNamePaths: false,\n        pathGrammar\n      }), intersectionParslet, predicateParslet, createKeyValueParslet({\n        allowVariadic: true,\n        allowOptional: true\n      })];\n      function parse3(expression, mode) {\n        switch (mode) {\n          case \"closure\":\n            return new Parser(closureGrammar, expression).parse();\n          case \"jsdoc\":\n            return new Parser(jsdocGrammar, expression).parse();\n          case \"typescript\":\n            return new Parser(typescriptGrammar, expression).parse();\n        }\n      }\n      __name(parse3, \"parse\");\n      function tryParse(expression, modes = [\"typescript\", \"closure\", \"jsdoc\"]) {\n        let error;\n        for (const mode of modes) {\n          try {\n            return parse3(expression, mode);\n          } catch (e) {\n            error = e;\n          }\n        }\n        throw error;\n      }\n      __name(tryParse, \"tryParse\");\n      function transform(rules2, parseResult) {\n        const rule = rules2[parseResult.type];\n        if (rule === void 0) {\n          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, aParseResult => transform(rules2, aParseResult));\n      }\n      __name(transform, \"transform\");\n      function notAvailableTransform(parseResult) {\n        throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n      }\n      __name(notAvailableTransform, \"notAvailableTransform\");\n      function extractSpecialParams(source) {\n        const result = {\n          params: []\n        };\n        for (const param of source.parameters) {\n          if (param.type === \"JsdocTypeKeyValue\") {\n            if (param.key === \"this\") {\n              result.this = param.right;\n            } else if (param.key === \"new\") {\n              result.new = param.right;\n            } else {\n              result.params.push(param);\n            }\n          } else {\n            result.params.push(param);\n          }\n        }\n        return result;\n      }\n      __name(extractSpecialParams, \"extractSpecialParams\");\n      function applyPosition(position, target, value) {\n        return position === \"prefix\" ? value + target : target + value;\n      }\n      __name(applyPosition, \"applyPosition\");\n      function quote(value, quote2) {\n        switch (quote2) {\n          case \"double\":\n            return `\"${value}\"`;\n          case \"single\":\n            return `'${value}'`;\n          case void 0:\n            return value;\n        }\n      }\n      __name(quote, \"quote\");\n      function stringifyRules2() {\n        return {\n          JsdocTypeParenthesis: /* @__PURE__ */__name((result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : \"\"})`, \"JsdocTypeParenthesis\"),\n          JsdocTypeKeyof: /* @__PURE__ */__name((result, transform2) => `keyof ${transform2(result.element)}`, \"JsdocTypeKeyof\"),\n          JsdocTypeFunction: /* @__PURE__ */__name((result, transform2) => {\n            var _a;\n            if (!result.arrow) {\n              let stringified = result.constructor ? \"new\" : \"function\";\n              if (!result.parenthesis) {\n                return stringified;\n              }\n              stringified += `(${result.parameters.map(transform2).join(\", \")})`;\n              if (result.returnType !== void 0) {\n                stringified += `: ${transform2(result.returnType)}`;\n              }\n              return stringified;\n            } else {\n              if (result.returnType === void 0) {\n                throw new Error(\"Arrow function needs a return type.\");\n              }\n              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(\", \")) !== null && _a !== void 0 ? _a : \"\"}>` : \"\"}(${result.parameters.map(transform2).join(\", \")}) => ${transform2(result.returnType)}`;\n              if (result.constructor) {\n                stringified = \"new \" + stringified;\n              }\n              return stringified;\n            }\n          }, \"JsdocTypeFunction\"),\n          JsdocTypeName: /* @__PURE__ */__name(result => result.value, \"JsdocTypeName\"),\n          JsdocTypeTuple: /* @__PURE__ */__name((result, transform2) => `[${result.elements.map(transform2).join(\", \")}]`, \"JsdocTypeTuple\"),\n          JsdocTypeVariadic: /* @__PURE__ */__name((result, transform2) => result.meta.position === void 0 ? \"...\" : applyPosition(result.meta.position, transform2(result.element), \"...\"), \"JsdocTypeVariadic\"),\n          JsdocTypeNamePath: /* @__PURE__ */__name((result, transform2) => {\n            const left = transform2(result.left);\n            const right = transform2(result.right);\n            switch (result.pathType) {\n              case \"inner\":\n                return `${left}~${right}`;\n              case \"instance\":\n                return `${left}#${right}`;\n              case \"property\":\n                return `${left}.${right}`;\n              case \"property-brackets\":\n                return `${left}[${right}]`;\n            }\n          }, \"JsdocTypeNamePath\"),\n          JsdocTypeStringValue: /* @__PURE__ */__name(result => quote(result.value, result.meta.quote), \"JsdocTypeStringValue\"),\n          JsdocTypeAny: /* @__PURE__ */__name(() => \"*\", \"JsdocTypeAny\"),\n          JsdocTypeGeneric: /* @__PURE__ */__name((result, transform2) => {\n            if (result.meta.brackets === \"square\") {\n              const element = result.elements[0];\n              const transformed = transform2(element);\n              if (element.type === \"JsdocTypeUnion\" || element.type === \"JsdocTypeIntersection\") {\n                return `(${transformed})[]`;\n              } else {\n                return `${transformed}[]`;\n              }\n            } else {\n              return `${transform2(result.left)}${result.meta.dot ? \".\" : \"\"}<${result.infer === true ? \"infer \" : \"\"}${result.elements.map(transform2).join(\", \")}>`;\n            }\n          }, \"JsdocTypeGeneric\"),\n          JsdocTypeImport: /* @__PURE__ */__name((result, transform2) => `import(${transform2(result.element)})`, \"JsdocTypeImport\"),\n          JsdocTypeObjectField: /* @__PURE__ */__name((result, transform2) => {\n            let text = \"\";\n            if (result.readonly) {\n              text += \"readonly \";\n            }\n            if (typeof result.key === \"string\") {\n              text += quote(result.key, result.meta.quote);\n            } else {\n              text += transform2(result.key);\n            }\n            if (result.optional) {\n              text += \"?\";\n            }\n            if (result.right === void 0) {\n              return text;\n            } else {\n              return text + `: ${transform2(result.right)}`;\n            }\n          }, \"JsdocTypeObjectField\"),\n          JsdocTypeJsdocObjectField: /* @__PURE__ */__name((result, transform2) => {\n            return `${transform2(result.left)}: ${transform2(result.right)}`;\n          }, \"JsdocTypeJsdocObjectField\"),\n          JsdocTypeKeyValue: /* @__PURE__ */__name((result, transform2) => {\n            let text = result.key;\n            if (result.optional) {\n              text += \"?\";\n            }\n            if (result.variadic) {\n              text = \"...\" + text;\n            }\n            if (result.right === void 0) {\n              return text;\n            } else {\n              return text + `: ${transform2(result.right)}`;\n            }\n          }, \"JsdocTypeKeyValue\"),\n          JsdocTypeSpecialNamePath: /* @__PURE__ */__name(result => `${result.specialType}:${quote(result.value, result.meta.quote)}`, \"JsdocTypeSpecialNamePath\"),\n          JsdocTypeNotNullable: /* @__PURE__ */__name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"!\"), \"JsdocTypeNotNullable\"),\n          JsdocTypeNull: /* @__PURE__ */__name(() => \"null\", \"JsdocTypeNull\"),\n          JsdocTypeNullable: /* @__PURE__ */__name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"?\"), \"JsdocTypeNullable\"),\n          JsdocTypeNumber: /* @__PURE__ */__name(result => result.value.toString(), \"JsdocTypeNumber\"),\n          JsdocTypeObject: /* @__PURE__ */__name((result, transform2) => {\n            var _a, _b;\n            return `{${(result.meta.separator === \"linebreak\" && result.elements.length > 1 ? \"\\n\" + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : \"\") : \"\") + result.elements.map(transform2).join(result.meta.separator === \"comma\" ? \", \" : result.meta.separator === \"linebreak\" ? \"\\n\" + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : \"\") : \"; \") + (result.meta.separator === \"linebreak\" && result.elements.length > 1 ? \"\\n\" : \"\")}}`;\n          }, \"JsdocTypeObject\"),\n          JsdocTypeOptional: /* @__PURE__ */__name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"=\"), \"JsdocTypeOptional\"),\n          JsdocTypeSymbol: /* @__PURE__ */__name((result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : \"\"})`, \"JsdocTypeSymbol\"),\n          JsdocTypeTypeof: /* @__PURE__ */__name((result, transform2) => `typeof ${transform2(result.element)}`, \"JsdocTypeTypeof\"),\n          JsdocTypeUndefined: /* @__PURE__ */__name(() => \"undefined\", \"JsdocTypeUndefined\"),\n          JsdocTypeUnion: /* @__PURE__ */__name((result, transform2) => result.elements.map(transform2).join(\" | \"), \"JsdocTypeUnion\"),\n          JsdocTypeUnknown: /* @__PURE__ */__name(() => \"?\", \"JsdocTypeUnknown\"),\n          JsdocTypeIntersection: /* @__PURE__ */__name((result, transform2) => result.elements.map(transform2).join(\" & \"), \"JsdocTypeIntersection\"),\n          JsdocTypeProperty: /* @__PURE__ */__name(result => quote(result.value, result.meta.quote), \"JsdocTypeProperty\"),\n          JsdocTypePredicate: /* @__PURE__ */__name((result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`, \"JsdocTypePredicate\"),\n          JsdocTypeIndexSignature: /* @__PURE__ */__name((result, transform2) => `[${result.key}: ${transform2(result.right)}]`, \"JsdocTypeIndexSignature\"),\n          JsdocTypeMappedType: /* @__PURE__ */__name((result, transform2) => `[${result.key} in ${transform2(result.right)}]`, \"JsdocTypeMappedType\"),\n          JsdocTypeAsserts: /* @__PURE__ */__name((result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`, \"JsdocTypeAsserts\"),\n          JsdocTypeReadonlyArray: /* @__PURE__ */__name((result, transform2) => `readonly ${transform2(result.element)}`, \"JsdocTypeReadonlyArray\"),\n          JsdocTypeAssertsPlain: /* @__PURE__ */__name((result, transform2) => `asserts ${transform2(result.element)}`, \"JsdocTypeAssertsPlain\"),\n          JsdocTypeConditional: /* @__PURE__ */__name((result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`, \"JsdocTypeConditional\"),\n          JsdocTypeTypeParameter: /* @__PURE__ */__name((result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : \"\"}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : \"\"}`, \"JsdocTypeTypeParameter\")\n        };\n      }\n      __name(stringifyRules2, \"stringifyRules\");\n      const storedStringifyRules = stringifyRules2();\n      function stringify2(result) {\n        return transform(storedStringifyRules, result);\n      }\n      __name(stringify2, \"stringify\");\n      const reservedWords = [\"null\", \"true\", \"false\", \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\", \"debugger\", \"default\", \"delete\", \"do\", \"else\", \"export\", \"extends\", \"finally\", \"for\", \"function\", \"if\", \"import\", \"in\", \"instanceof\", \"new\", \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\", \"void\", \"while\", \"with\", \"yield\"];\n      function makeName(value) {\n        const result = {\n          type: \"NameExpression\",\n          name: value\n        };\n        if (reservedWords.includes(value)) {\n          result.reservedWord = true;\n        }\n        return result;\n      }\n      __name(makeName, \"makeName\");\n      const catharsisTransformRules = {\n        JsdocTypeOptional: /* @__PURE__ */__name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.optional = true;\n          return transformed;\n        }, \"JsdocTypeOptional\"),\n        JsdocTypeNullable: /* @__PURE__ */__name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.nullable = true;\n          return transformed;\n        }, \"JsdocTypeNullable\"),\n        JsdocTypeNotNullable: /* @__PURE__ */__name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.nullable = false;\n          return transformed;\n        }, \"JsdocTypeNotNullable\"),\n        JsdocTypeVariadic: /* @__PURE__ */__name((result, transform2) => {\n          if (result.element === void 0) {\n            throw new Error(\"dots without value are not allowed in catharsis mode\");\n          }\n          const transformed = transform2(result.element);\n          transformed.repeatable = true;\n          return transformed;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeAny: /* @__PURE__ */__name(() => ({\n          type: \"AllLiteral\"\n        }), \"JsdocTypeAny\"),\n        JsdocTypeNull: /* @__PURE__ */__name(() => ({\n          type: \"NullLiteral\"\n        }), \"JsdocTypeNull\"),\n        JsdocTypeStringValue: /* @__PURE__ */__name(result => makeName(quote(result.value, result.meta.quote)), \"JsdocTypeStringValue\"),\n        JsdocTypeUndefined: /* @__PURE__ */__name(() => ({\n          type: \"UndefinedLiteral\"\n        }), \"JsdocTypeUndefined\"),\n        JsdocTypeUnknown: /* @__PURE__ */__name(() => ({\n          type: \"UnknownLiteral\"\n        }), \"JsdocTypeUnknown\"),\n        JsdocTypeFunction: /* @__PURE__ */__name((result, transform2) => {\n          const params = extractSpecialParams(result);\n          const transformed = {\n            type: \"FunctionType\",\n            params: params.params.map(transform2)\n          };\n          if (params.this !== void 0) {\n            transformed.this = transform2(params.this);\n          }\n          if (params.new !== void 0) {\n            transformed.new = transform2(params.new);\n          }\n          if (result.returnType !== void 0) {\n            transformed.result = transform2(result.returnType);\n          }\n          return transformed;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeGeneric: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"TypeApplication\",\n          applications: result.elements.map(o => transform2(o)),\n          expression: transform2(result.left)\n        }), \"JsdocTypeGeneric\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */__name(result => makeName(result.specialType + \":\" + quote(result.value, result.meta.quote)), \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeName: /* @__PURE__ */__name(result => {\n          if (result.value !== \"function\") {\n            return makeName(result.value);\n          } else {\n            return {\n              type: \"FunctionType\",\n              params: []\n            };\n          }\n        }, \"JsdocTypeName\"),\n        JsdocTypeNumber: /* @__PURE__ */__name(result => makeName(result.value.toString()), \"JsdocTypeNumber\"),\n        JsdocTypeObject: /* @__PURE__ */__name((result, transform2) => {\n          const transformed = {\n            type: \"RecordType\",\n            fields: []\n          };\n          for (const field of result.elements) {\n            if (field.type !== \"JsdocTypeObjectField\" && field.type !== \"JsdocTypeJsdocObjectField\") {\n              transformed.fields.push({\n                type: \"FieldType\",\n                key: transform2(field),\n                value: void 0\n              });\n            } else {\n              transformed.fields.push(transform2(field));\n            }\n          }\n          return transformed;\n        }, \"JsdocTypeObject\"),\n        JsdocTypeObjectField: /* @__PURE__ */__name((result, transform2) => {\n          if (typeof result.key !== \"string\") {\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          }\n          return {\n            type: \"FieldType\",\n            key: makeName(quote(result.key, result.meta.quote)),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"FieldType\",\n          key: transform2(result.left),\n          value: transform2(result.right)\n        }), \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeUnion: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"TypeUnion\",\n          elements: result.elements.map(e => transform2(e))\n        }), \"JsdocTypeUnion\"),\n        JsdocTypeKeyValue: /* @__PURE__ */__name((result, transform2) => {\n          return {\n            type: \"FieldType\",\n            key: makeName(result.key),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeNamePath: /* @__PURE__ */__name((result, transform2) => {\n          const leftResult = transform2(result.left);\n          let rightValue;\n          if (result.right.type === \"JsdocTypeSpecialNamePath\") {\n            rightValue = transform2(result.right).name;\n          } else {\n            rightValue = quote(result.right.value, result.right.meta.quote);\n          }\n          const joiner = result.pathType === \"inner\" ? \"~\" : result.pathType === \"instance\" ? \"#\" : \".\";\n          return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeSymbol: /* @__PURE__ */__name(result => {\n          let value = \"\";\n          let element = result.element;\n          let trailingDots = false;\n          if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeVariadic\") {\n            if (element.meta.position === \"prefix\") {\n              value = \"...\";\n            } else {\n              trailingDots = true;\n            }\n            element = element.element;\n          }\n          if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeName\") {\n            value += element.value;\n          } else if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeNumber\") {\n            value += element.value.toString();\n          }\n          if (trailingDots) {\n            value += \"...\";\n          }\n          return makeName(`${result.value}(${value})`);\n        }, \"JsdocTypeSymbol\"),\n        JsdocTypeParenthesis: /* @__PURE__ */__name((result, transform2) => transform2(assertRootResult(result.element)), \"JsdocTypeParenthesis\"),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n      }\n      __name(catharsisTransform, \"catharsisTransform\");\n      function getQuoteStyle(quote2) {\n        switch (quote2) {\n          case void 0:\n            return \"none\";\n          case \"single\":\n            return \"single\";\n          case \"double\":\n            return \"double\";\n        }\n      }\n      __name(getQuoteStyle, \"getQuoteStyle\");\n      function getMemberType(type) {\n        switch (type) {\n          case \"inner\":\n            return \"INNER_MEMBER\";\n          case \"instance\":\n            return \"INSTANCE_MEMBER\";\n          case \"property\":\n            return \"MEMBER\";\n          case \"property-brackets\":\n            return \"MEMBER\";\n        }\n      }\n      __name(getMemberType, \"getMemberType\");\n      function nestResults(type, results) {\n        if (results.length === 2) {\n          return {\n            type,\n            left: results[0],\n            right: results[1]\n          };\n        } else {\n          return {\n            type,\n            left: results[0],\n            right: nestResults(type, results.slice(1))\n          };\n        }\n      }\n      __name(nestResults, \"nestResults\");\n      const jtpRules = {\n        JsdocTypeOptional: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"OPTIONAL\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n          }\n        }), \"JsdocTypeOptional\"),\n        JsdocTypeNullable: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n          }\n        }), \"JsdocTypeNullable\"),\n        JsdocTypeNotNullable: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"NOT_NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n          }\n        }), \"JsdocTypeNotNullable\"),\n        JsdocTypeVariadic: /* @__PURE__ */__name((result, transform2) => {\n          const transformed = {\n            type: \"VARIADIC\",\n            meta: {\n              syntax: result.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : result.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n            }\n          };\n          if (result.element !== void 0) {\n            transformed.value = transform2(result.element);\n          }\n          return transformed;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeName: /* @__PURE__ */__name(result => ({\n          type: \"NAME\",\n          name: result.value\n        }), \"JsdocTypeName\"),\n        JsdocTypeTypeof: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"TYPE_QUERY\",\n          name: transform2(result.element)\n        }), \"JsdocTypeTypeof\"),\n        JsdocTypeTuple: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"TUPLE\",\n          entries: result.elements.map(transform2)\n        }), \"JsdocTypeTuple\"),\n        JsdocTypeKeyof: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"KEY_QUERY\",\n          value: transform2(result.element)\n        }), \"JsdocTypeKeyof\"),\n        JsdocTypeImport: /* @__PURE__ */__name(result => ({\n          type: \"IMPORT\",\n          path: {\n            type: \"STRING_VALUE\",\n            quoteStyle: getQuoteStyle(result.element.meta.quote),\n            string: result.element.value\n          }\n        }), \"JsdocTypeImport\"),\n        JsdocTypeUndefined: /* @__PURE__ */__name(() => ({\n          type: \"NAME\",\n          name: \"undefined\"\n        }), \"JsdocTypeUndefined\"),\n        JsdocTypeAny: /* @__PURE__ */__name(() => ({\n          type: \"ANY\"\n        }), \"JsdocTypeAny\"),\n        JsdocTypeFunction: /* @__PURE__ */__name((result, transform2) => {\n          const specialParams = extractSpecialParams(result);\n          const transformed = {\n            type: result.arrow ? \"ARROW\" : \"FUNCTION\",\n            params: specialParams.params.map(param => {\n              if (param.type === \"JsdocTypeKeyValue\") {\n                if (param.right === void 0) {\n                  throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n                }\n                return {\n                  type: \"NAMED_PARAMETER\",\n                  name: param.key,\n                  typeName: transform2(param.right)\n                };\n              } else {\n                return transform2(param);\n              }\n            }),\n            new: null,\n            returns: null\n          };\n          if (specialParams.this !== void 0) {\n            transformed.this = transform2(specialParams.this);\n          } else if (!result.arrow) {\n            transformed.this = null;\n          }\n          if (specialParams.new !== void 0) {\n            transformed.new = transform2(specialParams.new);\n          }\n          if (result.returnType !== void 0) {\n            transformed.returns = transform2(result.returnType);\n          }\n          return transformed;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeGeneric: /* @__PURE__ */__name((result, transform2) => {\n          const transformed = {\n            type: \"GENERIC\",\n            subject: transform2(result.left),\n            objects: result.elements.map(transform2),\n            meta: {\n              syntax: result.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : result.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n            }\n          };\n          if (result.meta.brackets === \"square\" && result.elements[0].type === \"JsdocTypeFunction\" && !result.elements[0].parenthesis) {\n            transformed.objects[0] = {\n              type: \"NAME\",\n              name: \"function\"\n            };\n          }\n          return transformed;\n        }, \"JsdocTypeGeneric\"),\n        JsdocTypeObjectField: /* @__PURE__ */__name((result, transform2) => {\n          if (typeof result.key !== \"string\") {\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          }\n          if (result.right === void 0) {\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              value: null,\n              readonly: false\n            };\n          }\n          let right = transform2(result.right);\n          if (result.optional) {\n            right = {\n              type: \"OPTIONAL\",\n              value: right,\n              meta: {\n                syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n              }\n            };\n          }\n          return {\n            type: \"RECORD_ENTRY\",\n            key: result.key.toString(),\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            value: right,\n            readonly: false\n          };\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */__name(() => {\n          throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n        }, \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */__name((result, transform2) => {\n          if (result.right === void 0) {\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: \"none\",\n              value: null,\n              readonly: false\n            };\n          }\n          let right = transform2(result.right);\n          if (result.optional) {\n            right = {\n              type: \"OPTIONAL\",\n              value: right,\n              meta: {\n                syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n              }\n            };\n          }\n          return {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: \"none\",\n            value: right,\n            readonly: false\n          };\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeObject: /* @__PURE__ */__name((result, transform2) => {\n          const entries = [];\n          for (const field of result.elements) {\n            if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") {\n              entries.push(transform2(field));\n            }\n          }\n          return {\n            type: \"RECORD\",\n            entries\n          };\n        }, \"JsdocTypeObject\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */__name(result => {\n          if (result.specialType !== \"module\") {\n            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n          }\n          return {\n            type: \"MODULE\",\n            value: {\n              type: \"FILE_PATH\",\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              path: result.value\n            }\n          };\n        }, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeNamePath: /* @__PURE__ */__name((result, transform2) => {\n          let hasEventPrefix = false;\n          let name;\n          let quoteStyle;\n          if (result.right.type === \"JsdocTypeSpecialNamePath\" && result.right.specialType === \"event\") {\n            hasEventPrefix = true;\n            name = result.right.value;\n            quoteStyle = getQuoteStyle(result.right.meta.quote);\n          } else {\n            name = result.right.value;\n            quoteStyle = getQuoteStyle(result.right.meta.quote);\n          }\n          const transformed = {\n            type: getMemberType(result.pathType),\n            owner: transform2(result.left),\n            name,\n            quoteStyle,\n            hasEventPrefix\n          };\n          if (transformed.owner.type === \"MODULE\") {\n            const tModule = transformed.owner;\n            transformed.owner = transformed.owner.value;\n            tModule.value = transformed;\n            return tModule;\n          } else {\n            return transformed;\n          }\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeUnion: /* @__PURE__ */__name((result, transform2) => nestResults(\"UNION\", result.elements.map(transform2)), \"JsdocTypeUnion\"),\n        JsdocTypeParenthesis: /* @__PURE__ */__name((result, transform2) => ({\n          type: \"PARENTHESIS\",\n          value: transform2(assertRootResult(result.element))\n        }), \"JsdocTypeParenthesis\"),\n        JsdocTypeNull: /* @__PURE__ */__name(() => ({\n          type: \"NAME\",\n          name: \"null\"\n        }), \"JsdocTypeNull\"),\n        JsdocTypeUnknown: /* @__PURE__ */__name(() => ({\n          type: \"UNKNOWN\"\n        }), \"JsdocTypeUnknown\"),\n        JsdocTypeStringValue: /* @__PURE__ */__name(result => ({\n          type: \"STRING_VALUE\",\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          string: result.value\n        }), \"JsdocTypeStringValue\"),\n        JsdocTypeIntersection: /* @__PURE__ */__name((result, transform2) => nestResults(\"INTERSECTION\", result.elements.map(transform2)), \"JsdocTypeIntersection\"),\n        JsdocTypeNumber: /* @__PURE__ */__name(result => ({\n          type: \"NUMBER_VALUE\",\n          number: result.value.toString()\n        }), \"JsdocTypeNumber\"),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function jtpTransform(result) {\n        return transform(jtpRules, result);\n      }\n      __name(jtpTransform, \"jtpTransform\");\n      function identityTransformRules() {\n        return {\n          JsdocTypeIntersection: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeIntersection\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeIntersection\"),\n          JsdocTypeGeneric: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeGeneric\",\n            left: transform2(result.left),\n            elements: result.elements.map(transform2),\n            meta: {\n              dot: result.meta.dot,\n              brackets: result.meta.brackets\n            }\n          }), \"JsdocTypeGeneric\"),\n          JsdocTypeNullable: /* @__PURE__ */__name(result => result, \"JsdocTypeNullable\"),\n          JsdocTypeUnion: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeUnion\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeUnion\"),\n          JsdocTypeUnknown: /* @__PURE__ */__name(result => result, \"JsdocTypeUnknown\"),\n          JsdocTypeUndefined: /* @__PURE__ */__name(result => result, \"JsdocTypeUndefined\"),\n          JsdocTypeTypeof: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeTypeof\",\n            element: transform2(result.element)\n          }), \"JsdocTypeTypeof\"),\n          JsdocTypeSymbol: /* @__PURE__ */__name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeSymbol\",\n              value: result.value\n            };\n            if (result.element !== void 0) {\n              transformed.element = transform2(result.element);\n            }\n            return transformed;\n          }, \"JsdocTypeSymbol\"),\n          JsdocTypeOptional: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeOptional\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }), \"JsdocTypeOptional\"),\n          JsdocTypeObject: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeObject\"),\n          JsdocTypeNumber: /* @__PURE__ */__name(result => result, \"JsdocTypeNumber\"),\n          JsdocTypeNull: /* @__PURE__ */__name(result => result, \"JsdocTypeNull\"),\n          JsdocTypeNotNullable: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeNotNullable\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }), \"JsdocTypeNotNullable\"),\n          JsdocTypeSpecialNamePath: /* @__PURE__ */__name(result => result, \"JsdocTypeSpecialNamePath\"),\n          JsdocTypeObjectField: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeObjectField\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            readonly: result.readonly,\n            meta: result.meta\n          }), \"JsdocTypeObjectField\"),\n          JsdocTypeJsdocObjectField: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeJsdocObjectField\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypeJsdocObjectField\"),\n          JsdocTypeKeyValue: /* @__PURE__ */__name((result, transform2) => {\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: result.key,\n              right: result.right === void 0 ? void 0 : transform2(result.right),\n              optional: result.optional,\n              variadic: result.variadic\n            };\n          }, \"JsdocTypeKeyValue\"),\n          JsdocTypeImport: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeImport\",\n            element: transform2(result.element)\n          }), \"JsdocTypeImport\"),\n          JsdocTypeAny: /* @__PURE__ */__name(result => result, \"JsdocTypeAny\"),\n          JsdocTypeStringValue: /* @__PURE__ */__name(result => result, \"JsdocTypeStringValue\"),\n          JsdocTypeNamePath: /* @__PURE__ */__name(result => result, \"JsdocTypeNamePath\"),\n          JsdocTypeVariadic: /* @__PURE__ */__name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeVariadic\",\n              meta: {\n                position: result.meta.position,\n                squareBrackets: result.meta.squareBrackets\n              }\n            };\n            if (result.element !== void 0) {\n              transformed.element = transform2(result.element);\n            }\n            return transformed;\n          }, \"JsdocTypeVariadic\"),\n          JsdocTypeTuple: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeTuple\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeTuple\"),\n          JsdocTypeName: /* @__PURE__ */__name(result => result, \"JsdocTypeName\"),\n          JsdocTypeFunction: /* @__PURE__ */__name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeFunction\",\n              arrow: result.arrow,\n              parameters: result.parameters.map(transform2),\n              constructor: result.constructor,\n              parenthesis: result.parenthesis\n            };\n            if (result.returnType !== void 0) {\n              transformed.returnType = transform2(result.returnType);\n            }\n            return transformed;\n          }, \"JsdocTypeFunction\"),\n          JsdocTypeKeyof: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeKeyof\",\n            element: transform2(result.element)\n          }), \"JsdocTypeKeyof\"),\n          JsdocTypeParenthesis: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeParenthesis\",\n            element: transform2(result.element)\n          }), \"JsdocTypeParenthesis\"),\n          JsdocTypeProperty: /* @__PURE__ */__name(result => result, \"JsdocTypeProperty\"),\n          JsdocTypePredicate: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypePredicate\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypePredicate\"),\n          JsdocTypeIndexSignature: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeIndexSignature\",\n            key: result.key,\n            right: transform2(result.right)\n          }), \"JsdocTypeIndexSignature\"),\n          JsdocTypeMappedType: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeMappedType\",\n            key: result.key,\n            right: transform2(result.right)\n          }), \"JsdocTypeMappedType\"),\n          JsdocTypeAsserts: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeAsserts\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypeAsserts\"),\n          JsdocTypeReadonlyArray: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeReadonlyArray\",\n            element: transform2(result.element)\n          }), \"JsdocTypeReadonlyArray\"),\n          JsdocTypeAssertsPlain: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeAssertsPlain\",\n            element: transform2(result.element)\n          }), \"JsdocTypeAssertsPlain\"),\n          JsdocTypeConditional: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeConditional\",\n            checksType: transform2(result.checksType),\n            extendsType: transform2(result.extendsType),\n            trueType: transform2(result.trueType),\n            falseType: transform2(result.falseType)\n          }), \"JsdocTypeConditional\"),\n          JsdocTypeTypeParameter: /* @__PURE__ */__name((result, transform2) => ({\n            type: \"JsdocTypeTypeParameter\",\n            name: transform2(result.name),\n            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,\n            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0\n          }), \"JsdocTypeTypeParameter\")\n        };\n      }\n      __name(identityTransformRules, \"identityTransformRules\");\n      const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: [\"parameters\", \"returnType\"],\n        JsdocTypeGeneric: [\"left\", \"elements\"],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: [\"right\"],\n        JsdocTypeIntersection: [\"elements\"],\n        JsdocTypeKeyof: [\"element\"],\n        JsdocTypeKeyValue: [\"right\"],\n        JsdocTypeMappedType: [\"right\"],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: [\"left\", \"right\"],\n        JsdocTypeNotNullable: [\"element\"],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: [\"element\"],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: [\"elements\"],\n        JsdocTypeObjectField: [\"right\"],\n        JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n        JsdocTypeOptional: [\"element\"],\n        JsdocTypeParenthesis: [\"element\"],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: [\"element\"],\n        JsdocTypeTuple: [\"elements\"],\n        JsdocTypeTypeof: [\"element\"],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: [\"elements\"],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: [\"element\"],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: [\"left\", \"right\"],\n        JsdocTypeAsserts: [\"left\", \"right\"],\n        JsdocTypeReadonlyArray: [\"element\"],\n        JsdocTypeAssertsPlain: [\"element\"],\n        JsdocTypeConditional: [\"checksType\", \"extendsType\", \"trueType\", \"falseType\"],\n        JsdocTypeTypeParameter: [\"name\", \"constraint\", \"defaultValue\"]\n      };\n      function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n          const value = node[key];\n          if (value !== void 0) {\n            if (Array.isArray(value)) {\n              for (const element of value) {\n                _traverse(element, node, key, onEnter, onLeave);\n              }\n            } else {\n              _traverse(value, node, key, onEnter, onLeave);\n            }\n          }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n      }\n      __name(_traverse, \"_traverse\");\n      function traverse(node, onEnter, onLeave) {\n        _traverse(node, void 0, void 0, onEnter, onLeave);\n      }\n      __name(traverse, \"traverse\");\n      exports2.catharsisTransform = catharsisTransform;\n      exports2.identityTransformRules = identityTransformRules;\n      exports2.jtpTransform = jtpTransform;\n      exports2.parse = parse3;\n      exports2.stringify = stringify2;\n      exports2.stringifyRules = stringifyRules2;\n      exports2.transform = transform;\n      exports2.traverse = traverse;\n      exports2.tryParse = tryParse;\n      exports2.visitorKeys = visitorKeys;\n    });\n  }\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError } from \"storybook/internal/preview-errors\";\nvar isLiteral = /* @__PURE__ */__name(type => type.name === \"literal\", \"isLiteral\");\nvar toEnumOption = /* @__PURE__ */__name(element => element.value.replace(/['|\"]/g, \"\"), \"toEnumOption\");\nvar convertSig = /* @__PURE__ */__name(type => {\n  switch (type.type) {\n    case \"function\":\n      return {\n        name: \"function\"\n      };\n    case \"object\":\n      const values = {};\n      type.signature.properties.forEach(prop => {\n        values[prop.key] = convert(prop.value);\n      });\n      return {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError({\n        type,\n        language: \"Flow\"\n      });\n  }\n}, \"convertSig\");\nvar convert = /* @__PURE__ */__name(type => {\n  const {\n    name,\n    raw\n  } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (type.name) {\n    case \"literal\":\n      return {\n        ...base,\n        name: \"other\",\n        value: type.value\n      };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      {\n        return {\n          ...base,\n          name\n        };\n      }\n    case \"Array\":\n      {\n        return {\n          ...base,\n          name: \"array\",\n          value: type.elements.map(convert)\n        };\n      }\n    case \"signature\":\n      return {\n        ...base,\n        ...convertSig(type)\n      };\n    case \"union\":\n      if (type.elements?.every(isLiteral)) {\n        return {\n          ...base,\n          name: \"enum\",\n          value: type.elements?.map(toEnumOption)\n        };\n      }\n      return {\n        ...base,\n        name,\n        value: type.elements?.map(convert)\n      };\n    case \"intersection\":\n      return {\n        ...base,\n        name,\n        value: type.elements?.map(convert)\n      };\n    default:\n      return {\n        ...base,\n        name: \"other\",\n        value: name\n      };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar QUOTE_REGEX = /^['\"]|['\"]$/g;\nvar trimQuotes = /* @__PURE__ */__name(str2 => str2.replace(QUOTE_REGEX, \"\"), \"trimQuotes\");\nvar includesQuotes = /* @__PURE__ */__name(str2 => QUOTE_REGEX.test(str2), \"includesQuotes\");\nvar parseLiteral = /* @__PURE__ */__name(str2 => {\n  const trimmedValue = trimQuotes(str2);\n  return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);\n}, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar SIGNATURE_REGEXP = /^\\(.*\\) => /;\nvar convert2 = /* @__PURE__ */__name(type => {\n  const {\n    name,\n    raw,\n    computed,\n    value\n  } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (name) {\n    case \"enum\":\n      {\n        const values2 = computed ? value : value.map(v => parseLiteral(v.value));\n        return {\n          ...base,\n          name,\n          value: values2\n        };\n      }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return {\n        ...base,\n        name\n      };\n    case \"func\":\n      return {\n        ...base,\n        name: \"function\"\n      };\n    case \"bool\":\n    case \"boolean\":\n      return {\n        ...base,\n        name: \"boolean\"\n      };\n    case \"arrayOf\":\n    case \"array\":\n      return {\n        ...base,\n        name: \"array\",\n        value: value && convert2(value)\n      };\n    case \"object\":\n      return {\n        ...base,\n        name\n      };\n    case \"objectOf\":\n      return {\n        ...base,\n        name,\n        value: convert2(value)\n      };\n    case \"shape\":\n    case \"exact\":\n      const values = mapValues(value, field => convert2(field));\n      return {\n        ...base,\n        name: \"object\",\n        value: values\n      };\n    case \"union\":\n      return {\n        ...base,\n        name: \"union\",\n        value: value.map(v => convert2(v))\n      };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default:\n      {\n        if (name?.indexOf(\"|\") > 0) {\n          try {\n            const literalValues = name.split(\"|\").map(v => JSON.parse(v));\n            return {\n              ...base,\n              name: \"enum\",\n              value: literalValues\n            };\n          } catch (err) {}\n        }\n        const otherVal = value ? `${name}(${value})` : name;\n        const otherName = SIGNATURE_REGEXP.test(name) ? \"function\" : \"other\";\n        return {\n          ...base,\n          name: otherName,\n          value: otherVal\n        };\n      }\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as UnknownArgTypesError2 } from \"storybook/internal/preview-errors\";\nvar convertSig2 = /* @__PURE__ */__name(type => {\n  switch (type.type) {\n    case \"function\":\n      return {\n        name: \"function\"\n      };\n    case \"object\":\n      const values = {};\n      type.signature.properties.forEach(prop => {\n        values[prop.key] = convert3(prop.value);\n      });\n      return {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError2({\n        type,\n        language: \"Typescript\"\n      });\n  }\n}, \"convertSig\");\nvar convert3 = /* @__PURE__ */__name(type => {\n  const {\n    name,\n    raw\n  } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (type.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      {\n        return {\n          ...base,\n          name\n        };\n      }\n    case \"Array\":\n      {\n        return {\n          ...base,\n          name: \"array\",\n          value: type.elements.map(convert3)\n        };\n      }\n    case \"signature\":\n      return {\n        ...base,\n        ...convertSig2(type)\n      };\n    case \"union\":\n      let result;\n      if (type.elements?.every(element => element.name === \"literal\")) {\n        result = {\n          ...base,\n          name: \"enum\",\n          // @ts-expect-error fix types\n          value: type.elements?.map(v => parseLiteral(v.value))\n        };\n      } else {\n        result = {\n          ...base,\n          name,\n          value: type.elements?.map(convert3)\n        };\n      }\n      return result;\n    case \"intersection\":\n      return {\n        ...base,\n        name,\n        value: type.elements?.map(convert3)\n      };\n    default:\n      return {\n        ...base,\n        name: \"other\",\n        value: name\n      };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar convert4 = /* @__PURE__ */__name(docgenInfo => {\n  const {\n    type,\n    tsType,\n    flowType\n  } = docgenInfo;\n  try {\n    if (type != null) {\n      return convert2(type);\n    }\n    if (tsType != null) {\n      return convert3(tsType);\n    }\n    if (flowType != null) {\n      return convert(flowType);\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar TypeSystem = /* @__PURE__ */(TypeSystem2 => {\n  TypeSystem2[\"JAVASCRIPT\"] = \"JavaScript\";\n  TypeSystem2[\"FLOW\"] = \"Flow\";\n  TypeSystem2[\"TYPESCRIPT\"] = \"TypeScript\";\n  TypeSystem2[\"UNKNOWN\"] = \"Unknown\";\n  return TypeSystem2;\n})(TypeSystem || {});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar BLACKLIST = [\"null\", \"undefined\"];\nfunction isDefaultValueBlacklisted(value) {\n  return BLACKLIST.some(x => x === value);\n}\n__name(isDefaultValueBlacklisted, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar str = /* @__PURE__ */__name(obj => {\n  if (!obj) {\n    return \"\";\n  }\n  if (typeof obj === \"string\") {\n    return obj;\n  }\n  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction hasDocgen(component) {\n  return !!component.__docgenInfo;\n}\n__name(hasDocgen, \"hasDocgen\");\nfunction isValidDocgenSection(docgenSection) {\n  return docgenSection != null && Object.keys(docgenSection).length > 0;\n}\n__name(isValidDocgenSection, \"isValidDocgenSection\");\nfunction getDocgenSection(component, section) {\n  return hasDocgen(component) ? component.__docgenInfo[section] : null;\n}\n__name(getDocgenSection, \"getDocgenSection\");\nfunction getDocgenDescription(component) {\n  return hasDocgen(component) ? str(component.__docgenInfo.description) : \"\";\n}\n__name(getDocgenDescription, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar Markers;\n(function (Markers2) {\n  Markers2[\"start\"] = \"/**\";\n  Markers2[\"nostart\"] = \"/***\";\n  Markers2[\"delim\"] = \"*\";\n  Markers2[\"end\"] = \"*/\";\n})(Markers = Markers || (Markers = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction isSpace(source) {\n  return /^\\s+$/.test(source);\n}\n__name(isSpace, \"isSpace\");\nfunction splitCR(source) {\n  const matches = source.match(/\\r+$/);\n  return matches == null ? [\"\", source] : [source.slice(-matches[0].length), source.slice(0, -matches[0].length)];\n}\n__name(splitCR, \"splitCR\");\nfunction splitSpace(source) {\n  const matches = source.match(/^\\s+/);\n  return matches == null ? [\"\", source] : [source.slice(0, matches[0].length), source.slice(matches[0].length)];\n}\n__name(splitSpace, \"splitSpace\");\nfunction splitLines(source) {\n  return source.split(/\\n/);\n}\n__name(splitLines, \"splitLines\");\nfunction seedSpec(spec = {}) {\n  return Object.assign({\n    tag: \"\",\n    name: \"\",\n    type: \"\",\n    optional: false,\n    description: \"\",\n    problems: [],\n    source: []\n  }, spec);\n}\n__name(seedSpec, \"seedSpec\");\nfunction seedTokens(tokens = {}) {\n  return Object.assign({\n    start: \"\",\n    delimiter: \"\",\n    postDelimiter: \"\",\n    tag: \"\",\n    postTag: \"\",\n    name: \"\",\n    postName: \"\",\n    type: \"\",\n    postType: \"\",\n    description: \"\",\n    end: \"\",\n    lineEnd: \"\"\n  }, tokens);\n}\n__name(seedTokens, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar reTag = /^@\\S+/;\nfunction getParser({\n  fence = \"```\"\n} = {}) {\n  const fencer = getFencer(fence);\n  const toggleFence = /* @__PURE__ */__name((source, isFenced) => fencer(source) ? !isFenced : isFenced, \"toggleFence\");\n  return /* @__PURE__ */__name(function parseBlock(source) {\n    const sections = [[]];\n    let isFenced = false;\n    for (const line of source) {\n      if (reTag.test(line.tokens.description) && !isFenced) {\n        sections.push([line]);\n      } else {\n        sections[sections.length - 1].push(line);\n      }\n      isFenced = toggleFence(line.tokens.description, isFenced);\n    }\n    return sections;\n  }, \"parseBlock\");\n}\n__name(getParser, \"getParser\");\nfunction getFencer(fence) {\n  if (typeof fence === \"string\") return source => source.split(fence).length % 2 === 0;\n  return fence;\n}\n__name(getFencer, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction getParser2({\n  startLine = 0,\n  markers = Markers\n} = {}) {\n  let block = null;\n  let num = startLine;\n  return /* @__PURE__ */__name(function parseSource(source) {\n    let rest = source;\n    const tokens = seedTokens();\n    [tokens.lineEnd, rest] = splitCR(rest);\n    [tokens.start, rest] = splitSpace(rest);\n    if (block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart)) {\n      block = [];\n      tokens.delimiter = rest.slice(0, markers.start.length);\n      rest = rest.slice(markers.start.length);\n      [tokens.postDelimiter, rest] = splitSpace(rest);\n    }\n    if (block === null) {\n      num++;\n      return null;\n    }\n    const isClosed = rest.trimRight().endsWith(markers.end);\n    if (tokens.delimiter === \"\" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end)) {\n      tokens.delimiter = markers.delim;\n      rest = rest.slice(markers.delim.length);\n      [tokens.postDelimiter, rest] = splitSpace(rest);\n    }\n    if (isClosed) {\n      const trimmed = rest.trimRight();\n      tokens.end = rest.slice(trimmed.length - markers.end.length);\n      rest = trimmed.slice(0, -markers.end.length);\n    }\n    tokens.description = rest;\n    block.push({\n      number: num,\n      source,\n      tokens\n    });\n    num++;\n    if (isClosed) {\n      const result = block.slice();\n      block = null;\n      return result;\n    }\n    return null;\n  }, \"parseSource\");\n}\n__name(getParser2, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction getParser3({\n  tokenizers\n}) {\n  return /* @__PURE__ */__name(function parseSpec(source) {\n    var _a;\n    let spec = seedSpec({\n      source\n    });\n    for (const tokenize of tokenizers) {\n      spec = tokenize(spec);\n      if ((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0 ? void 0 : _a.critical) break;\n    }\n    return spec;\n  }, \"parseSpec\");\n}\n__name(getParser3, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction tagTokenizer() {\n  return spec => {\n    const {\n      tokens\n    } = spec.source[0];\n    const match = tokens.description.match(/\\s*(@(\\S+))(\\s*)/);\n    if (match === null) {\n      spec.problems.push({\n        code: \"spec:tag:prefix\",\n        message: 'tag should start with \"@\" symbol',\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    tokens.tag = match[1];\n    tokens.postTag = match[3];\n    tokens.description = tokens.description.slice(match[0].length);\n    spec.tag = match[2];\n    return spec;\n  };\n}\n__name(tagTokenizer, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction typeTokenizer(spacing = \"compact\") {\n  const join2 = getJoiner(spacing);\n  return spec => {\n    let curlies = 0;\n    let lines = [];\n    for (const [i, {\n      tokens\n    }] of spec.source.entries()) {\n      let type = \"\";\n      if (i === 0 && tokens.description[0] !== \"{\") return spec;\n      for (const ch of tokens.description) {\n        if (ch === \"{\") curlies++;\n        if (ch === \"}\") curlies--;\n        type += ch;\n        if (curlies === 0) break;\n      }\n      lines.push([tokens, type]);\n      if (curlies === 0) break;\n    }\n    if (curlies !== 0) {\n      spec.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    const parts = [];\n    const offset = lines[0][0].postDelimiter.length;\n    for (const [i, [tokens, type]] of lines.entries()) {\n      tokens.type = type;\n      if (i > 0) {\n        tokens.type = tokens.postDelimiter.slice(offset) + type;\n        tokens.postDelimiter = tokens.postDelimiter.slice(0, offset);\n      }\n      [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length));\n      parts.push(tokens.type);\n    }\n    parts[0] = parts[0].slice(1);\n    parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1);\n    spec.type = join2(parts);\n    return spec;\n  };\n}\n__name(typeTokenizer, \"typeTokenizer\");\nvar trim = /* @__PURE__ */__name(x => x.trim(), \"trim\");\nfunction getJoiner(spacing) {\n  if (spacing === \"compact\") return t => t.map(trim).join(\"\");else if (spacing === \"preserve\") return t => t.join(\"\\n\");else return spacing;\n}\n__name(getJoiner, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar isQuoted = /* @__PURE__ */__name(s => s && s.startsWith('\"') && s.endsWith('\"'), \"isQuoted\");\nfunction nameTokenizer() {\n  const typeEnd = /* @__PURE__ */__name((num, {\n    tokens\n  }, i) => tokens.type === \"\" ? num : i, \"typeEnd\");\n  return spec => {\n    const {\n      tokens\n    } = spec.source[spec.source.reduce(typeEnd, 0)];\n    const source = tokens.description.trimLeft();\n    const quotedGroups = source.split('\"');\n    if (quotedGroups.length > 1 && quotedGroups[0] === \"\" && quotedGroups.length % 2 === 1) {\n      spec.name = quotedGroups[1];\n      tokens.name = `\"${quotedGroups[1]}\"`;\n      [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));\n      return spec;\n    }\n    let brackets = 0;\n    let name = \"\";\n    let optional = false;\n    let defaultValue;\n    for (const ch of source) {\n      if (brackets === 0 && isSpace(ch)) break;\n      if (ch === \"[\") brackets++;\n      if (ch === \"]\") brackets--;\n      name += ch;\n    }\n    if (brackets !== 0) {\n      spec.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    const nameToken = name;\n    if (name[0] === \"[\" && name[name.length - 1] === \"]\") {\n      optional = true;\n      name = name.slice(1, -1);\n      const parts = name.split(\"=\");\n      name = parts[0].trim();\n      if (parts[1] !== void 0) defaultValue = parts.slice(1).join(\"=\").trim();\n      if (name === \"\") {\n        spec.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n      if (defaultValue === \"\") {\n        spec.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue)) {\n        spec.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n    }\n    spec.optional = optional;\n    spec.name = name;\n    tokens.name = nameToken;\n    if (defaultValue !== void 0) spec.default = defaultValue;\n    [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));\n    return spec;\n  };\n}\n__name(nameTokenizer, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction descriptionTokenizer(spacing = \"compact\", markers = Markers) {\n  const join2 = getJoiner2(spacing);\n  return spec => {\n    spec.description = join2(spec.source, markers);\n    return spec;\n  };\n}\n__name(descriptionTokenizer, \"descriptionTokenizer\");\nfunction getJoiner2(spacing) {\n  if (spacing === \"compact\") return compactJoiner;\n  if (spacing === \"preserve\") return preserveJoiner;\n  return spacing;\n}\n__name(getJoiner2, \"getJoiner\");\nfunction compactJoiner(lines, markers = Markers) {\n  return lines.map(({\n    tokens: {\n      description\n    }\n  }) => description.trim()).filter(description => description !== \"\").join(\" \");\n}\n__name(compactJoiner, \"compactJoiner\");\nvar lineNo = /* @__PURE__ */__name((num, {\n  tokens\n}, i) => tokens.type === \"\" ? num : i, \"lineNo\");\nvar getDescription = /* @__PURE__ */__name(({\n  tokens\n}) => (tokens.delimiter === \"\" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description, \"getDescription\");\nfunction preserveJoiner(lines, markers = Markers) {\n  if (lines.length === 0) return \"\";\n  if (lines[0].tokens.description === \"\" && lines[0].tokens.delimiter === markers.start) lines = lines.slice(1);\n  const lastLine = lines[lines.length - 1];\n  if (lastLine !== void 0 && lastLine.tokens.description === \"\" && lastLine.tokens.end.endsWith(markers.end)) lines = lines.slice(0, -1);\n  lines = lines.slice(lines.reduce(lineNo, 0));\n  return lines.map(getDescription).join(\"\\n\");\n}\n__name(preserveJoiner, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction getParser4({\n  startLine = 0,\n  fence = \"```\",\n  spacing = \"compact\",\n  markers = Markers,\n  tokenizers = [tagTokenizer(), typeTokenizer(spacing), nameTokenizer(), descriptionTokenizer(spacing)]\n} = {}) {\n  if (startLine < 0 || startLine % 1 > 0) throw new Error(\"Invalid startLine\");\n  const parseSource = getParser2({\n    startLine,\n    markers\n  });\n  const parseBlock = getParser({\n    fence\n  });\n  const parseSpec = getParser3({\n    tokenizers\n  });\n  const joinDescription = getJoiner2(spacing);\n  return function (source) {\n    const blocks = [];\n    for (const line of splitLines(source)) {\n      const lines = parseSource(line);\n      if (lines === null) continue;\n      const sections = parseBlock(lines);\n      const specs = sections.slice(1).map(parseSpec);\n      blocks.push({\n        description: joinDescription(sections[0], markers),\n        tags: specs,\n        source: lines,\n        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])\n      });\n    }\n    return blocks;\n  };\n}\n__name(getParser4, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction join(tokens) {\n  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;\n}\n__name(join, \"join\");\nfunction getStringifier() {\n  return block => block.source.map(({\n    tokens\n  }) => join(tokens)).join(\"\\n\");\n}\n__name(getStringifier, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar zeroWidth = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar fields = Object.keys(zeroWidth);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction parse(source, options = {}) {\n  return getParser4(options)(source);\n}\n__name(parse, \"parse\");\nvar stringify = getStringifier();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);\nfunction containsJsDoc(value) {\n  return value != null && value.includes(\"@\");\n}\n__name(containsJsDoc, \"containsJsDoc\");\nfunction parse2(content) {\n  const contentString = content ?? \"\";\n  const mappedLines = contentString.split(\"\\n\").map(line => ` * ${line}`).join(\"\\n\");\n  const normalisedContent = \"/**\\n\" + mappedLines + \"\\n*/\";\n  const ast = parse(normalisedContent, {\n    spacing: \"preserve\"\n  });\n  if (!ast || ast.length === 0) {\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  }\n  return ast[0];\n}\n__name(parse2, \"parse\");\nvar DEFAULT_OPTIONS = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n};\nvar parseJsDoc = /* @__PURE__ */__name((value, options = DEFAULT_OPTIONS) => {\n  if (!containsJsDoc(value)) {\n    return {\n      includesJsDoc: false,\n      ignore: false\n    };\n  }\n  const jsDocAst = parse2(value);\n  const extractedTags = extractJsDocTags(jsDocAst, options.tags);\n  if (extractedTags.ignore) {\n    return {\n      includesJsDoc: true,\n      ignore: true\n    };\n  }\n  return {\n    includesJsDoc: true,\n    ignore: false,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description.trim(),\n    extractedTags\n  };\n}, \"parseJsDoc\");\nfunction extractJsDocTags(ast, tags) {\n  const extractedTags = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: false\n  };\n  for (const tagSpec of ast.tags) {\n    if (tags !== void 0 && !tags.includes(tagSpec.tag)) {\n      continue;\n    }\n    if (tagSpec.tag === \"ignore\") {\n      extractedTags.ignore = true;\n      break;\n    } else {\n      switch (tagSpec.tag) {\n        // arg & argument are aliases for param.\n        case \"param\":\n        case \"arg\":\n        case \"argument\":\n          {\n            const paramTag = extractParam(tagSpec);\n            if (paramTag != null) {\n              if (extractedTags.params == null) {\n                extractedTags.params = [];\n              }\n              extractedTags.params.push(paramTag);\n            }\n            break;\n          }\n        case \"deprecated\":\n          {\n            const deprecatedTag = extractDeprecated(tagSpec);\n            if (deprecatedTag != null) {\n              extractedTags.deprecated = deprecatedTag;\n            }\n            break;\n          }\n        case \"returns\":\n          {\n            const returnsTag = extractReturns(tagSpec);\n            if (returnsTag != null) {\n              extractedTags.returns = returnsTag;\n            }\n            break;\n          }\n        default:\n          break;\n      }\n    }\n  }\n  return extractedTags;\n}\n__name(extractJsDocTags, \"extractJsDocTags\");\nfunction normaliseParamName(name) {\n  return name.replace(/[\\.-]$/, \"\");\n}\n__name(normaliseParamName, \"normaliseParamName\");\nfunction extractParam(tag) {\n  if (!tag.name || tag.name === \"-\") {\n    return null;\n  }\n  const type = extractType(tag.type);\n  return {\n    name: tag.name,\n    type,\n    description: normaliseDescription(tag.description),\n    getPrettyName: /* @__PURE__ */__name(() => {\n      return normaliseParamName(tag.name);\n    }, \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */__name(() => {\n      return type ? extractTypeName(type) : null;\n    }, \"getTypeName\")\n  };\n}\n__name(extractParam, \"extractParam\");\nfunction extractDeprecated(tag) {\n  if (tag.name) {\n    return joinNameAndDescription(tag.name, tag.description);\n  }\n  return null;\n}\n__name(extractDeprecated, \"extractDeprecated\");\nfunction joinNameAndDescription(name, desc) {\n  const joined = name === \"\" ? desc : `${name} ${desc}`;\n  return normaliseDescription(joined);\n}\n__name(joinNameAndDescription, \"joinNameAndDescription\");\nfunction normaliseDescription(text) {\n  const normalised = text.replace(/^- /g, \"\").trim();\n  return normalised === \"\" ? null : normalised;\n}\n__name(normaliseDescription, \"normaliseDescription\");\nfunction extractReturns(tag) {\n  const type = extractType(tag.type);\n  if (type) {\n    return {\n      type,\n      description: joinNameAndDescription(tag.name, tag.description),\n      getTypeName: /* @__PURE__ */__name(() => {\n        return extractTypeName(type);\n      }, \"getTypeName\")\n    };\n  }\n  return null;\n}\n__name(extractReturns, \"extractReturns\");\nvar jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)();\nvar originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;\njsdocStringifyRules.JsdocTypeAny = () => \"any\";\njsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;\njsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join(\"|\");\nfunction extractType(typeString) {\n  try {\n    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, \"typescript\");\n  } catch (_err) {\n    return null;\n  }\n}\n__name(extractType, \"extractType\");\nfunction extractTypeName(type) {\n  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);\n}\n__name(extractTypeName, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar MAX_TYPE_SUMMARY_LENGTH = 90;\nvar MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;\nfunction isTooLongForTypeSummary(value) {\n  return value.length > MAX_TYPE_SUMMARY_LENGTH;\n}\n__name(isTooLongForTypeSummary, \"isTooLongForTypeSummary\");\nfunction isTooLongForDefaultValueSummary(value) {\n  return value.length > MAX_DEFAULT_VALUE_SUMMARY_LENGTH;\n}\n__name(isTooLongForDefaultValueSummary, \"isTooLongForDefaultValueSummary\");\nfunction createSummaryValue(summary, detail) {\n  if (summary === detail) {\n    return {\n      summary\n    };\n  }\n  return {\n    summary,\n    detail\n  };\n}\n__name(createSummaryValue, \"createSummaryValue\");\nvar normalizeNewlines = /* @__PURE__ */__name(string => string.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction createDefaultValue(defaultValue, type) {\n  if (defaultValue != null) {\n    const {\n      value\n    } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      return !isTooLongForDefaultValueSummary(value) ? createSummaryValue(value) : createSummaryValue(type?.name, value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction generateUnionElement({\n  name,\n  value,\n  elements,\n  raw\n}) {\n  if (value != null) {\n    return value;\n  }\n  if (elements != null) {\n    return elements.map(generateUnionElement).join(\" | \");\n  }\n  if (raw != null) {\n    return raw;\n  }\n  return name;\n}\n__name(generateUnionElement, \"generateUnionElement\");\nfunction generateUnion({\n  name,\n  raw,\n  elements\n}) {\n  if (elements != null) {\n    return createSummaryValue(elements.map(generateUnionElement).join(\" | \"));\n  }\n  if (raw != null) {\n    return createSummaryValue(raw.replace(/^\\|\\s*/, \"\"));\n  }\n  return createSummaryValue(name);\n}\n__name(generateUnion, \"generateUnion\");\nfunction generateFuncSignature({\n  type,\n  raw\n}) {\n  if (raw != null) {\n    return createSummaryValue(raw);\n  }\n  return createSummaryValue(type);\n}\n__name(generateFuncSignature, \"generateFuncSignature\");\nfunction generateObjectSignature({\n  type,\n  raw\n}) {\n  if (raw != null) {\n    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(type, raw);\n  }\n  return createSummaryValue(type);\n}\n__name(generateObjectSignature, \"generateObjectSignature\");\nfunction generateSignature(flowType) {\n  const {\n    type\n  } = flowType;\n  return type === \"object\" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);\n}\n__name(generateSignature, \"generateSignature\");\nfunction generateDefault({\n  name,\n  raw\n}) {\n  if (raw != null) {\n    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(name, raw);\n  }\n  return createSummaryValue(name);\n}\n__name(generateDefault, \"generateDefault\");\nfunction createType(type) {\n  if (type == null) {\n    return null;\n  }\n  switch (type.name) {\n    case \"union\" /* UNION */:\n      return generateUnion(type);\n    case \"signature\" /* SIGNATURE */:\n      return generateSignature(type);\n    default:\n      return generateDefault(type);\n  }\n}\n__name(createType, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar createFlowPropDef = /* @__PURE__ */__name((propName, docgenInfo) => {\n  const {\n    flowType,\n    description,\n    required,\n    defaultValue\n  } = docgenInfo;\n  return {\n    name: propName,\n    type: createType(flowType),\n    required,\n    description,\n    defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction createDefaultValue2({\n  defaultValue\n}) {\n  if (defaultValue != null) {\n    const {\n      value\n    } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      return createSummaryValue(value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue2, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction createType2({\n  tsType,\n  required\n}) {\n  if (tsType == null) {\n    return null;\n  }\n  let typeName = tsType.name;\n  if (!required) {\n    typeName = typeName.replace(\" | undefined\", \"\");\n  }\n  return createSummaryValue([\"Array\", \"Record\", \"signature\"].includes(tsType.name) ? tsType.raw : typeName);\n}\n__name(createType2, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar createTsPropDef = /* @__PURE__ */__name((propName, docgenInfo) => {\n  const {\n    description,\n    required\n  } = docgenInfo;\n  return {\n    name: propName,\n    type: createType2(docgenInfo),\n    required,\n    description,\n    defaultValue: createDefaultValue2(docgenInfo)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction createType3(type) {\n  return type != null ? createSummaryValue(type.name) : null;\n}\n__name(createType3, \"createType\");\nfunction isReactDocgenTypescript(defaultValue) {\n  const {\n    computed,\n    func\n  } = defaultValue;\n  return typeof computed === \"undefined\" && typeof func === \"undefined\";\n}\n__name(isReactDocgenTypescript, \"isReactDocgenTypescript\");\nfunction isStringValued(type) {\n  if (!type) {\n    return false;\n  }\n  if (type.name === \"string\") {\n    return true;\n  }\n  if (type.name === \"enum\") {\n    return Array.isArray(type.value) && type.value.every(({\n      value: tv\n    }) => typeof tv === \"string\" && tv[0] === '\"' && tv[tv.length - 1] === '\"');\n  }\n  return false;\n}\n__name(isStringValued, \"isStringValued\");\nfunction createDefaultValue3(defaultValue, type) {\n  if (defaultValue != null) {\n    const {\n      value\n    } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      if (isReactDocgenTypescript(defaultValue) && isStringValued(type)) {\n        return createSummaryValue(JSON.stringify(value));\n      }\n      return createSummaryValue(value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue3, \"createDefaultValue\");\nfunction createBasicPropDef(name, type, docgenInfo) {\n  const {\n    description,\n    required,\n    defaultValue\n  } = docgenInfo;\n  return {\n    name,\n    type: createType3(type),\n    required,\n    description,\n    defaultValue: createDefaultValue3(defaultValue, type)\n  };\n}\n__name(createBasicPropDef, \"createBasicPropDef\");\nfunction applyJsDocResult(propDef, jsDocParsingResult) {\n  if (jsDocParsingResult?.includesJsDoc) {\n    const {\n      description,\n      extractedTags\n    } = jsDocParsingResult;\n    if (description != null) {\n      propDef.description = jsDocParsingResult.description;\n    }\n    const value = {\n      ...extractedTags,\n      params: extractedTags?.params?.map(x => ({\n        name: x.getPrettyName(),\n        description: x.description\n      }))\n    };\n    if (Object.values(value).filter(Boolean).length > 0) {\n      propDef.jsDocTags = value;\n    }\n  }\n  return propDef;\n}\n__name(applyJsDocResult, \"applyJsDocResult\");\nvar javaScriptFactory = /* @__PURE__ */__name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"javaScriptFactory\");\nvar tsFactory = /* @__PURE__ */__name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createTsPropDef(propName, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"tsFactory\");\nvar flowFactory = /* @__PURE__ */__name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createFlowPropDef(propName, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"flowFactory\");\nvar unknownFactory = /* @__PURE__ */__name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createBasicPropDef(propName, {\n    name: \"unknown\"\n  }, docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"unknownFactory\");\nvar getPropDefFactory = /* @__PURE__ */__name(typeSystem => {\n  switch (typeSystem) {\n    case \"JavaScript\" /* JAVASCRIPT */:\n      return javaScriptFactory;\n    case \"TypeScript\" /* TYPESCRIPT */:\n      return tsFactory;\n    case \"Flow\" /* FLOW */:\n      return flowFactory;\n    default:\n      return unknownFactory;\n  }\n}, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar getTypeSystem = /* @__PURE__ */__name(docgenInfo => {\n  if (docgenInfo.type != null) {\n    return \"JavaScript\" /* JAVASCRIPT */;\n  }\n  if (docgenInfo.flowType != null) {\n    return \"Flow\" /* FLOW */;\n  }\n  if (docgenInfo.tsType != null) {\n    return \"TypeScript\" /* TYPESCRIPT */;\n  }\n  return \"Unknown\" /* UNKNOWN */;\n}, \"getTypeSystem\");\nvar extractComponentSectionArray = /* @__PURE__ */__name(docgenSection => {\n  const typeSystem = getTypeSystem(docgenSection[0]);\n  const createPropDef = getPropDefFactory(typeSystem);\n  return docgenSection.map(item => {\n    let sanitizedItem = item;\n    if (item.type?.elements) {\n      sanitizedItem = {\n        ...item,\n        type: {\n          ...item.type,\n          value: item.type.elements\n        }\n      };\n    }\n    return extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);\n  });\n}, \"extractComponentSectionArray\");\nvar extractComponentSectionObject = /* @__PURE__ */__name(docgenSection => {\n  const docgenPropsKeys = Object.keys(docgenSection);\n  const typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]);\n  const createPropDef = getPropDefFactory(typeSystem);\n  return docgenPropsKeys.map(propName => {\n    const docgenInfo = docgenSection[propName];\n    return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;\n  }).filter(Boolean);\n}, \"extractComponentSectionObject\");\nvar extractComponentProps = /* @__PURE__ */__name((component, section) => {\n  const docgenSection = getDocgenSection(component, section);\n  if (!isValidDocgenSection(docgenSection)) {\n    return [];\n  }\n  return Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection);\n}, \"extractComponentProps\");\nfunction extractProp(propName, docgenInfo, typeSystem, createPropDef) {\n  const jsDocParsingResult = parseJsDoc(docgenInfo.description);\n  const isIgnored = jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore;\n  if (!isIgnored) {\n    const propDef = createPropDef(propName, docgenInfo, jsDocParsingResult);\n    return {\n      propDef,\n      jsDocTags: jsDocParsingResult.extractedTags,\n      docgenInfo,\n      typeSystem\n    };\n  }\n  return null;\n}\n__name(extractProp, \"extractProp\");\nfunction extractComponentDescription(component) {\n  return component != null ? getDocgenDescription(component) : \"\";\n}\n__name(extractComponentDescription, \"extractComponentDescription\");\n\n// src/preview-api/modules/store/parameters.ts\nvar combineParameters = /* @__PURE__ */__name((...parameterSets) => {\n  const mergeKeys = {};\n  const definedParametersSets = parameterSets.filter(Boolean);\n  const combined = definedParametersSets.reduce((acc, parameters) => {\n    Object.entries(parameters).forEach(([key, value]) => {\n      const existing = acc[key];\n      if (Array.isArray(value) || typeof existing === \"undefined\") {\n        acc[key] = value;\n      } else if (isPlainObject(value) && isPlainObject(existing)) {\n        mergeKeys[key] = true;\n      } else if (typeof value !== \"undefined\") {\n        acc[key] = value;\n      }\n    });\n    return acc;\n  }, {});\n  Object.keys(mergeKeys).forEach(key => {\n    const mergeValues = definedParametersSets.filter(Boolean).map(p => p[key]).filter(value => typeof value !== \"undefined\");\n    if (mergeValues.every(value => isPlainObject(value))) {\n      combined[key] = combineParameters(...mergeValues);\n    } else {\n      combined[key] = mergeValues[mergeValues.length - 1];\n    }\n  });\n  return combined;\n}, \"combineParameters\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar enhanceArgTypes = /* @__PURE__ */__name(context => {\n  const {\n    component,\n    argTypes: userArgTypes,\n    parameters: {\n      docs = {}\n    }\n  } = context;\n  const {\n    extractArgTypes\n  } = docs;\n  if (!extractArgTypes || !component) {\n    return userArgTypes;\n  }\n  const extractedArgTypes = extractArgTypes(component);\n  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar ADDON_ID = \"storybook/docs\";\nvar PANEL_ID = `${ADDON_ID}/panel`;\nvar PARAM_KEY = `docs`;\nvar SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`;\nvar SourceType = /* @__PURE__ */(SourceType2 => {\n  SourceType2[\"AUTO\"] = \"auto\";\n  SourceType2[\"CODE\"] = \"code\";\n  SourceType2[\"DYNAMIC\"] = \"dynamic\";\n  return SourceType2;\n})(SourceType || {});\nexport { combineParameters, convert4 as convert, TypeSystem, isDefaultValueBlacklisted, str, hasDocgen, isValidDocgenSection, getDocgenSection, getDocgenDescription, parseJsDoc, MAX_TYPE_SUMMARY_LENGTH, MAX_DEFAULT_VALUE_SUMMARY_LENGTH, isTooLongForTypeSummary, isTooLongForDefaultValueSummary, createSummaryValue, normalizeNewlines, extractComponentSectionArray, extractComponentSectionObject, extractComponentProps, extractComponentDescription, enhanceArgTypes, ADDON_ID, PANEL_ID, PARAM_KEY, SNIPPET_RENDERED, SourceType };","map":{"version":3,"names":["mapValues","isPlainObject","__commonJS","__name","__toESM","require_dist","../node_modules/jsdoc-type-pratt-parser/dist/index.js","exports","module","global","factory","define","amd","globalThis","self","jtpp","exports2","tokenToString","token","text","type","_NoParsletFoundError","Error","constructor","Object","setPrototypeOf","prototype","getToken","NoParsletFoundError","_EarlyEndOfParseError","EarlyEndOfParseError","_UnexpectedTypeError","result","message","error","UnexpectedTypeError","makePunctuationRule","startsWith","getQuoted","position","char","mark","escaped","length","slice","identifierStartRegex","RegExp","identifierContinueRegex","getIdentifier","test","numberRegex","getNumber","_a","_b","exec","identifierRule","value","makeKeyWordRule","prepends","stringValueRule","eofRule","numberRule","rules","breakingWhitespaceRegex","_Lexer","create","current","read","next","previous","startOfLine","trim","rule","partial","assign","advance","Lexer","assertRootResult","assertPlainKeyValueOrRootResult","assertPlainKeyValueResult","assertPlainKeyValueOrNameResult","assertNumberOrVariadicNameResult","element","assertArrayOrTupleResult","meta","brackets","isSquaredProperty","Precedence","Precedence2","_Parser","grammar","textOrLexer","baseParser","_lexer","lexer","parse","parseType","ALL","precedence","parseIntermediateType","tryParslets","parseInfixIntermediateType","left","parslet","consume","types","Array","isArray","includes","acceptLexerState","parser","Parser","isQuestionMarkUnknownType","nullableParslet","accept","NULLABLE","composeParslet","options","curPrecedence","parsePrefix","parseInfix","defineProperty","name","optionalParslet","OPTIONAL","numberParslet","parseFloat","parenthesisParslet","elements","specialTypesParslet","notNullableParslet","createParameterListParslet","allowTrailingComma","PARAMETER_LIST","push","e","some","genericParslet","GENERIC","dot","objects","infer","left2","SYMBOL","unionParslet","UNION","baseGrammar","createNamePathParslet","allowSquareBracketsOnAnyType","allowJsdocNamePaths","pathGrammar","pathGrammar2","namePathParslet","NAME_PATH","pathType","pathParser","parsed","right","quote","toString","specialType","createNameParslet","allowedAdditionalTokens","stringValueParslet","createSpecialNamePathParslet","allowedTypes","allowed","type2","moduleParser","moduleResult","basePathGrammar","getParameters","parameters","map","p","getUnnamedParameters","createFunctionParslet","allowNamedParameters","allowNoReturnType","allowWithoutParenthesis","allowNewAsFunctionKeyword","newKeyword","hasParenthesis","arrow","parenthesis","FUNCTION","key","join","returnType","PREFIX","createVariadicParslet","allowPostfix","allowEnclosingBrackets","squareBrackets","symbolParslet","arrayBracketsParslet","ARRAY_BRACKETS","createObjectParslet","objectFieldGrammar","objectFieldGrammar2","allowKeyTypes","separator","fieldParser","field","OBJECT","optional","quote2","readonly","propertyIndent","createObjectFieldParslet","allowSquaredProperties","allowReadonly","allowOptional","KEY_VALUE","readonlyProperty","parentParser","createKeyValueParslet","allowVariadic","variadic","jsdocBaseGrammar","jsdocGrammar","typeOfParslet","KEY_OF_TYPE_OF","objectFieldGrammar$1","closureGrammar","assertsParslet","INFIX","createTupleParslet","allowQuestionMark","typeList","keyOfParslet","importParslet","path","readonlyPropertyParslet","arrowFunctionParslet","ARROW","genericArrowFunctionParslet","typeParameters","defaultValue","constraint","typeParameter","functionBase","intersectionParslet","INTERSECTION","predicateParslet","objectSquaredPropertyParslet","INDEX_BRACKETS","readonlyArrayParslet","conditionalParslet","extendsType","trueType","checksType","falseType","typescriptGrammar","parse3","expression","mode","tryParse","modes","transform","rules2","parseResult","aParseResult","notAvailableTransform","extractSpecialParams","source","params","param","this","new","applyPosition","target","stringifyRules2","JsdocTypeParenthesis","transform2","JsdocTypeKeyof","JsdocTypeFunction","stringified","JsdocTypeName","JsdocTypeTuple","JsdocTypeVariadic","JsdocTypeNamePath","JsdocTypeStringValue","JsdocTypeAny","JsdocTypeGeneric","transformed","JsdocTypeImport","JsdocTypeObjectField","JsdocTypeJsdocObjectField","JsdocTypeKeyValue","JsdocTypeSpecialNamePath","JsdocTypeNotNullable","JsdocTypeNull","JsdocTypeNullable","JsdocTypeNumber","JsdocTypeObject","JsdocTypeOptional","JsdocTypeSymbol","JsdocTypeTypeof","JsdocTypeUndefined","JsdocTypeUnion","JsdocTypeUnknown","JsdocTypeIntersection","JsdocTypeProperty","JsdocTypePredicate","JsdocTypeIndexSignature","JsdocTypeMappedType","JsdocTypeAsserts","JsdocTypeReadonlyArray","JsdocTypeAssertsPlain","JsdocTypeConditional","JsdocTypeTypeParameter","storedStringifyRules","stringify2","reservedWords","makeName","reservedWord","catharsisTransformRules","nullable","repeatable","applications","o","fields","leftResult","rightValue","joiner","trailingDots","catharsisTransform","getQuoteStyle","getMemberType","nestResults","results","jtpRules","syntax","entries","quoteStyle","string","specialParams","typeName","returns","subject","hasEventPrefix","owner","tModule","number","jtpTransform","identityTransformRules","visitorKeys","_traverse","node","parentNode","property","onEnter","onLeave","keysToVisit","traverse","stringify","stringifyRules","UnknownArgTypesError","isLiteral","toEnumOption","replace","convertSig","values","signature","properties","forEach","prop","convert","language","raw","base","every","QUOTE_REGEX","trimQuotes","str2","includesQuotes","parseLiteral","trimmedValue","Number","isNaN","SIGNATURE_REGEXP","convert2","computed","values2","v","indexOf","literalValues","split","JSON","err","otherVal","otherName","UnknownArgTypesError2","convertSig2","convert3","convert4","docgenInfo","tsType","flowType","console","TypeSystem","TypeSystem2","BLACKLIST","isDefaultValueBlacklisted","x","str","obj","hasDocgen","component","__docgenInfo","isValidDocgenSection","docgenSection","keys","getDocgenSection","section","getDocgenDescription","description","Markers","Markers2","isSpace","splitCR","matches","match","splitSpace","splitLines","seedSpec","spec","tag","problems","seedTokens","tokens","start","delimiter","postDelimiter","postTag","postName","postType","end","lineEnd","reTag","getParser","fence","fencer","getFencer","toggleFence","isFenced","parseBlock","sections","line","getParser2","startLine","markers","block","num","parseSource","rest","nostart","isClosed","trimRight","endsWith","delim","trimmed","getParser3","tokenizers","parseSpec","tokenize","critical","tagTokenizer","code","typeTokenizer","spacing","join2","getJoiner","curlies","lines","i","ch","parts","offset","t","isQuoted","s","nameTokenizer","typeEnd","reduce","trimLeft","quotedGroups","nameToken","default","descriptionTokenizer","getJoiner2","compactJoiner","preserveJoiner","filter","lineNo","getDescription","lastLine","getParser4","joinDescription","blocks","specs","tags","acc","concat","getStringifier","zeroWidth","import_jsdoc_type_pratt_parser","containsJsDoc","parse2","content","contentString","mappedLines","normalisedContent","ast","DEFAULT_OPTIONS","parseJsDoc","includesJsDoc","ignore","jsDocAst","extractedTags","extractJsDocTags","deprecated","tagSpec","paramTag","extractParam","deprecatedTag","extractDeprecated","returnsTag","extractReturns","normaliseParamName","extractType","normaliseDescription","getPrettyName","getTypeName","extractTypeName","joinNameAndDescription","desc","joined","normalised","jsdocStringifyRules","originalJsdocStringifyObject","typeString","_err","MAX_TYPE_SUMMARY_LENGTH","MAX_DEFAULT_VALUE_SUMMARY_LENGTH","isTooLongForTypeSummary","isTooLongForDefaultValueSummary","createSummaryValue","summary","detail","normalizeNewlines","createDefaultValue","generateUnionElement","generateUnion","generateFuncSignature","generateObjectSignature","generateSignature","generateDefault","createType","createFlowPropDef","propName","required","createDefaultValue2","createType2","createTsPropDef","createType3","isReactDocgenTypescript","func","isStringValued","tv","createDefaultValue3","createBasicPropDef","applyJsDocResult","propDef","jsDocParsingResult","Boolean","jsDocTags","javaScriptFactory","sbType","tsFactory","flowFactory","unknownFactory","getPropDefFactory","typeSystem","getTypeSystem","extractComponentSectionArray","createPropDef","item","sanitizedItem","extractProp","extractComponentSectionObject","docgenPropsKeys","extractComponentProps","isIgnored","extractComponentDescription","combineParameters","parameterSets","mergeKeys","definedParametersSets","combined","existing","mergeValues","enhanceArgTypes","context","argTypes","userArgTypes","docs","extractArgTypes","extractedArgTypes","ADDON_ID","PANEL_ID","PARAM_KEY","SNIPPET_RENDERED","SourceType","SourceType2"],"sources":["/Users/ugurcakil/Documents/projects/ugurk/ng-theme-storybook/node_modules/storybook/dist/_browser-chunks/chunk-U2JWIJRX.js"],"sourcesContent":["import {\n  mapValues\n} from \"./chunk-KHNISLMN.js\";\nimport {\n  isPlainObject\n} from \"./chunk-FSBVR7H5.js\";\nimport {\n  __commonJS,\n  __name,\n  __toESM\n} from \"./chunk-MM7DTO55.js\";\n\n// ../node_modules/jsdoc-type-pratt-parser/dist/index.js\nvar require_dist = __commonJS({\n  \"../node_modules/jsdoc-type-pratt-parser/dist/index.js\"(exports, module) {\n    (function(global, factory) {\n      typeof exports === \"object\" && typeof module !== \"undefined\" ? factory(exports) : typeof define === \"function\" && define.amd ? define([\"exports\"], factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, factory(global.jtpp = {}));\n    })(exports, function(exports2) {\n      \"use strict\";\n      function tokenToString(token) {\n        if (token.text !== void 0 && token.text !== \"\") {\n          return `'${token.type}' with value '${token.text}'`;\n        } else {\n          return `'${token.type}'`;\n        }\n      }\n      __name(tokenToString, \"tokenToString\");\n      const _NoParsletFoundError = class _NoParsletFoundError extends Error {\n        constructor(token) {\n          super(`No parslet found for token: ${tokenToString(token)}`);\n          this.token = token;\n          Object.setPrototypeOf(this, _NoParsletFoundError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n      __name(_NoParsletFoundError, \"NoParsletFoundError\");\n      let NoParsletFoundError = _NoParsletFoundError;\n      const _EarlyEndOfParseError = class _EarlyEndOfParseError extends Error {\n        constructor(token) {\n          super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n          this.token = token;\n          Object.setPrototypeOf(this, _EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n          return this.token;\n        }\n      };\n      __name(_EarlyEndOfParseError, \"EarlyEndOfParseError\");\n      let EarlyEndOfParseError = _EarlyEndOfParseError;\n      const _UnexpectedTypeError = class _UnexpectedTypeError extends Error {\n        constructor(result, message) {\n          let error = `Unexpected type: '${result.type}'.`;\n          if (message !== void 0) {\n            error += ` Message: ${message}`;\n          }\n          super(error);\n          Object.setPrototypeOf(this, _UnexpectedTypeError.prototype);\n        }\n      };\n      __name(_UnexpectedTypeError, \"UnexpectedTypeError\");\n      let UnexpectedTypeError = _UnexpectedTypeError;\n      function makePunctuationRule(type) {\n        return (text) => {\n          if (text.startsWith(type)) {\n            return { type, text: type };\n          } else {\n            return null;\n          }\n        };\n      }\n      __name(makePunctuationRule, \"makePunctuationRule\");\n      function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== \"'\" && mark !== '\"') {\n          return null;\n        }\n        while (position < text.length) {\n          position++;\n          char = text[position];\n          if (!escaped && char === mark) {\n            position++;\n            break;\n          }\n          escaped = !escaped && char === \"\\\\\";\n        }\n        if (char !== mark) {\n          throw new Error(\"Unterminated String\");\n        }\n        return text.slice(0, position);\n      }\n      __name(getQuoted, \"getQuoted\");\n      const identifierStartRegex = new RegExp(\"[$_\\\\p{ID_Start}]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      const identifierContinueRegex = new RegExp(\"[$\\\\-\\\\p{ID_Continue}\\\\u200C\\\\u200D]|\\\\\\\\u\\\\p{Hex_Digit}{4}|\\\\\\\\u\\\\{0*(?:\\\\p{Hex_Digit}{1,5}|10\\\\p{Hex_Digit}{4})\\\\}\", \"u\");\n      function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n          return null;\n        }\n        let position = 1;\n        do {\n          char = text[position];\n          if (!identifierContinueRegex.test(char)) {\n            break;\n          }\n          position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n      }\n      __name(getIdentifier, \"getIdentifier\");\n      const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n      function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n      }\n      __name(getNumber, \"getNumber\");\n      const identifierRule = /* @__PURE__ */ __name((text) => {\n        const value = getIdentifier(text);\n        if (value == null) {\n          return null;\n        }\n        return {\n          type: \"Identifier\",\n          text: value\n        };\n      }, \"identifierRule\");\n      function makeKeyWordRule(type) {\n        return (text) => {\n          if (!text.startsWith(type)) {\n            return null;\n          }\n          const prepends = text[type.length];\n          if (prepends !== void 0 && identifierContinueRegex.test(prepends)) {\n            return null;\n          }\n          return {\n            type,\n            text: type\n          };\n        };\n      }\n      __name(makeKeyWordRule, \"makeKeyWordRule\");\n      const stringValueRule = /* @__PURE__ */ __name((text) => {\n        const value = getQuoted(text);\n        if (value == null) {\n          return null;\n        }\n        return {\n          type: \"StringValue\",\n          text: value\n        };\n      }, \"stringValueRule\");\n      const eofRule = /* @__PURE__ */ __name((text) => {\n        if (text.length > 0) {\n          return null;\n        }\n        return {\n          type: \"EOF\",\n          text: \"\"\n        };\n      }, \"eofRule\");\n      const numberRule = /* @__PURE__ */ __name((text) => {\n        const value = getNumber(text);\n        if (value === null) {\n          return null;\n        }\n        return {\n          type: \"Number\",\n          text: value\n        };\n      }, \"numberRule\");\n      const rules = [\n        eofRule,\n        makePunctuationRule(\"=>\"),\n        makePunctuationRule(\"(\"),\n        makePunctuationRule(\")\"),\n        makePunctuationRule(\"{\"),\n        makePunctuationRule(\"}\"),\n        makePunctuationRule(\"[\"),\n        makePunctuationRule(\"]\"),\n        makePunctuationRule(\"|\"),\n        makePunctuationRule(\"&\"),\n        makePunctuationRule(\"<\"),\n        makePunctuationRule(\">\"),\n        makePunctuationRule(\",\"),\n        makePunctuationRule(\";\"),\n        makePunctuationRule(\"*\"),\n        makePunctuationRule(\"?\"),\n        makePunctuationRule(\"!\"),\n        makePunctuationRule(\"=\"),\n        makePunctuationRule(\":\"),\n        makePunctuationRule(\"...\"),\n        makePunctuationRule(\".\"),\n        makePunctuationRule(\"#\"),\n        makePunctuationRule(\"~\"),\n        makePunctuationRule(\"/\"),\n        makePunctuationRule(\"@\"),\n        makeKeyWordRule(\"undefined\"),\n        makeKeyWordRule(\"null\"),\n        makeKeyWordRule(\"function\"),\n        makeKeyWordRule(\"this\"),\n        makeKeyWordRule(\"new\"),\n        makeKeyWordRule(\"module\"),\n        makeKeyWordRule(\"event\"),\n        makeKeyWordRule(\"extends\"),\n        makeKeyWordRule(\"external\"),\n        makeKeyWordRule(\"infer\"),\n        makeKeyWordRule(\"typeof\"),\n        makeKeyWordRule(\"keyof\"),\n        makeKeyWordRule(\"readonly\"),\n        makeKeyWordRule(\"import\"),\n        makeKeyWordRule(\"is\"),\n        makeKeyWordRule(\"in\"),\n        makeKeyWordRule(\"asserts\"),\n        numberRule,\n        identifierRule,\n        stringValueRule\n      ];\n      const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n      const _Lexer = class _Lexer {\n        static create(text) {\n          const current = this.read(text);\n          text = current.text;\n          const next = this.read(text);\n          text = next.text;\n          return new _Lexer(text, void 0, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n          this.text = \"\";\n          this.text = text;\n          this.previous = previous;\n          this.current = current;\n          this.next = next;\n        }\n        static read(text, startOfLine = false) {\n          startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n          text = text.trim();\n          for (const rule of rules) {\n            const partial = rule(text);\n            if (partial !== null) {\n              const token = Object.assign(Object.assign({}, partial), { startOfLine });\n              text = text.slice(token.text.length);\n              return { text, token };\n            }\n          }\n          throw new Error(\"Unexpected Token \" + text);\n        }\n        advance() {\n          const next = _Lexer.read(this.text);\n          return new _Lexer(next.text, this.current, this.next, next.token);\n        }\n      };\n      __name(_Lexer, \"Lexer\");\n      let Lexer = _Lexer;\n      function assertRootResult(result) {\n        if (result === void 0) {\n          throw new Error(\"Unexpected undefined\");\n        }\n        if (result.type === \"JsdocTypeKeyValue\" || result.type === \"JsdocTypeParameterList\" || result.type === \"JsdocTypeProperty\" || result.type === \"JsdocTypeReadonlyProperty\" || result.type === \"JsdocTypeObjectField\" || result.type === \"JsdocTypeJsdocObjectField\" || result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\" || result.type === \"JsdocTypeTypeParameter\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertRootResult, \"assertRootResult\");\n      function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === \"JsdocTypeKeyValue\") {\n          return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n      }\n      __name(assertPlainKeyValueOrRootResult, \"assertPlainKeyValueOrRootResult\");\n      function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === \"JsdocTypeName\") {\n          return result;\n        }\n        return assertPlainKeyValueResult(result);\n      }\n      __name(assertPlainKeyValueOrNameResult, \"assertPlainKeyValueOrNameResult\");\n      function assertPlainKeyValueResult(result) {\n        if (result.type !== \"JsdocTypeKeyValue\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertPlainKeyValueResult, \"assertPlainKeyValueResult\");\n      function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === \"JsdocTypeVariadic\") {\n          if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === \"JsdocTypeName\") {\n            return result;\n          }\n          throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== \"JsdocTypeNumber\" && result.type !== \"JsdocTypeName\") {\n          throw new UnexpectedTypeError(result);\n        }\n        return result;\n      }\n      __name(assertNumberOrVariadicNameResult, \"assertNumberOrVariadicNameResult\");\n      function assertArrayOrTupleResult(result) {\n        if (result.type === \"JsdocTypeTuple\") {\n          return result;\n        }\n        if (result.type === \"JsdocTypeGeneric\" && result.meta.brackets === \"square\") {\n          return result;\n        }\n        throw new UnexpectedTypeError(result);\n      }\n      __name(assertArrayOrTupleResult, \"assertArrayOrTupleResult\");\n      function isSquaredProperty(result) {\n        return result.type === \"JsdocTypeIndexSignature\" || result.type === \"JsdocTypeMappedType\";\n      }\n      __name(isSquaredProperty, \"isSquaredProperty\");\n      var Precedence;\n      (function(Precedence2) {\n        Precedence2[Precedence2[\"ALL\"] = 0] = \"ALL\";\n        Precedence2[Precedence2[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence2[Precedence2[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence2[Precedence2[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence2[Precedence2[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence2[Precedence2[\"UNION\"] = 5] = \"UNION\";\n        Precedence2[Precedence2[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence2[Precedence2[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence2[Precedence2[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence2[Precedence2[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence2[Precedence2[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence2[Precedence2[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence2[Precedence2[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence2[Precedence2[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence2[Precedence2[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence2[Precedence2[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence2[Precedence2[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence2[Precedence2[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence2[Precedence2[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence2[Precedence2[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence2[Precedence2[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n      })(Precedence || (Precedence = {}));\n      const _Parser = class _Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n          this.grammar = grammar;\n          if (typeof textOrLexer === \"string\") {\n            this._lexer = Lexer.create(textOrLexer);\n          } else {\n            this._lexer = textOrLexer;\n          }\n          this.baseParser = baseParser;\n        }\n        get lexer() {\n          return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n          const result = this.parseType(Precedence.ALL);\n          if (this.lexer.current.type !== \"EOF\") {\n            throw new EarlyEndOfParseError(this.lexer.current);\n          }\n          return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n          return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n          const result = this.tryParslets(null, precedence);\n          if (result === null) {\n            throw new NoParsletFoundError(this.lexer.current);\n          }\n          return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n          let result = this.tryParslets(left, precedence);\n          while (result !== null) {\n            left = result;\n            result = this.tryParslets(left, precedence);\n          }\n          return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n          for (const parslet of this.grammar) {\n            const result = parslet(this, precedence, left);\n            if (result !== null) {\n              return result;\n            }\n          }\n          return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n          if (!Array.isArray(types)) {\n            types = [types];\n          }\n          if (types.includes(this.lexer.current.type)) {\n            this._lexer = this.lexer.advance();\n            return true;\n          } else {\n            return false;\n          }\n        }\n        acceptLexerState(parser) {\n          this._lexer = parser.lexer;\n        }\n      };\n      __name(_Parser, \"Parser\");\n      let Parser = _Parser;\n      function isQuestionMarkUnknownType(next) {\n        return next === \"}\" || next === \"EOF\" || next === \"|\" || next === \",\" || next === \")\" || next === \">\";\n      }\n      __name(isQuestionMarkUnknownType, \"isQuestionMarkUnknownType\");\n      const nullableParslet = /* @__PURE__ */ __name((parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = left == null && type === \"?\" && !isQuestionMarkUnknownType(next) || left != null && type === \"?\";\n        if (!accept) {\n          return null;\n        }\n        parser.consume(\"?\");\n        if (left == null) {\n          return {\n            type: \"JsdocTypeNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        } else {\n          return {\n            type: \"JsdocTypeNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }\n      }, \"nullableParslet\");\n      function composeParslet(options) {\n        const parslet = /* @__PURE__ */ __name((parser, curPrecedence, left) => {\n          const type = parser.lexer.current.type;\n          const next = parser.lexer.next.type;\n          if (left === null) {\n            if (\"parsePrefix\" in options) {\n              if (options.accept(type, next)) {\n                return options.parsePrefix(parser);\n              }\n            }\n          } else {\n            if (\"parseInfix\" in options) {\n              if (options.precedence > curPrecedence && options.accept(type, next)) {\n                return options.parseInfix(parser, left);\n              }\n            }\n          }\n          return null;\n        }, \"parslet\");\n        Object.defineProperty(parslet, \"name\", {\n          value: options.name\n        });\n        return parslet;\n      }\n      __name(composeParslet, \"composeParslet\");\n      const optionalParslet = composeParslet({\n        name: \"optionalParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"=\", \"accept\"),\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"=\");\n          return {\n            type: \"JsdocTypeOptional\",\n            element: parser.parseType(Precedence.OPTIONAL),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        }, \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"=\");\n          return {\n            type: \"JsdocTypeOptional\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }, \"parseInfix\")\n      });\n      const numberParslet = composeParslet({\n        name: \"numberParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"Number\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const value = parseFloat(parser.lexer.current.text);\n          parser.consume(\"Number\");\n          return {\n            type: \"JsdocTypeNumber\",\n            value\n          };\n        }, \"parsePrefix\")\n      });\n      const parenthesisParslet = composeParslet({\n        name: \"parenthesisParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"(\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"(\");\n          if (parser.consume(\")\")) {\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: []\n            };\n          }\n          const result = parser.parseIntermediateType(Precedence.ALL);\n          if (!parser.consume(\")\")) {\n            throw new Error(\"Unterminated parenthesis\");\n          }\n          if (result.type === \"JsdocTypeParameterList\") {\n            return result;\n          } else if (result.type === \"JsdocTypeKeyValue\") {\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements: [result]\n            };\n          }\n          return {\n            type: \"JsdocTypeParenthesis\",\n            element: assertRootResult(result)\n          };\n        }, \"parsePrefix\")\n      });\n      const specialTypesParslet = composeParslet({\n        name: \"specialTypesParslet\",\n        accept: /* @__PURE__ */ __name((type, next) => type === \"?\" && isQuestionMarkUnknownType(next) || type === \"null\" || type === \"undefined\" || type === \"*\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          if (parser.consume(\"null\")) {\n            return {\n              type: \"JsdocTypeNull\"\n            };\n          }\n          if (parser.consume(\"undefined\")) {\n            return {\n              type: \"JsdocTypeUndefined\"\n            };\n          }\n          if (parser.consume(\"*\")) {\n            return {\n              type: \"JsdocTypeAny\"\n            };\n          }\n          if (parser.consume(\"?\")) {\n            return {\n              type: \"JsdocTypeUnknown\"\n            };\n          }\n          throw new Error(\"Unacceptable token: \" + parser.lexer.current.text);\n        }, \"parsePrefix\")\n      });\n      const notNullableParslet = composeParslet({\n        name: \"notNullableParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"!\", \"accept\"),\n        precedence: Precedence.NULLABLE,\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"!\");\n          return {\n            type: \"JsdocTypeNotNullable\",\n            element: parser.parseType(Precedence.NULLABLE),\n            meta: {\n              position: \"prefix\"\n            }\n          };\n        }, \"parsePrefix\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"!\");\n          return {\n            type: \"JsdocTypeNotNullable\",\n            element: assertRootResult(left),\n            meta: {\n              position: \"suffix\"\n            }\n          };\n        }, \"parseInfix\")\n      });\n      function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n          name: \"parameterListParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \",\", \"accept\"),\n          precedence: Precedence.PARAMETER_LIST,\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            const elements = [\n              assertPlainKeyValueOrRootResult(left)\n            ];\n            parser.consume(\",\");\n            do {\n              try {\n                const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                elements.push(assertPlainKeyValueOrRootResult(next));\n              } catch (e) {\n                if (e instanceof NoParsletFoundError) {\n                  break;\n                } else {\n                  throw e;\n                }\n              }\n            } while (parser.consume(\",\"));\n            if (elements.length > 0 && elements.slice(0, -1).some((e) => e.type === \"JsdocTypeVariadic\")) {\n              throw new Error(\"Only the last parameter may be a rest parameter\");\n            }\n            return {\n              type: \"JsdocTypeParameterList\",\n              elements\n            };\n          }, \"parseInfix\")\n        });\n      }\n      __name(createParameterListParslet, \"createParameterListParslet\");\n      const genericParslet = composeParslet({\n        name: \"genericParslet\",\n        accept: /* @__PURE__ */ __name((type, next) => type === \"<\" || type === \".\" && next === \"<\", \"accept\"),\n        precedence: Precedence.GENERIC,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          const dot = parser.consume(\".\");\n          parser.consume(\"<\");\n          const objects = [];\n          let infer = false;\n          if (parser.consume(\"infer\")) {\n            infer = true;\n            const left2 = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left2.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(left2, \"A typescript asserts always has to have a name on the left side.\");\n            }\n            objects.push(left2);\n          } else {\n            do {\n              objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            } while (parser.consume(\",\"));\n          }\n          if (!parser.consume(\">\")) {\n            throw new Error(\"Unterminated generic parameter list\");\n          }\n          return Object.assign(Object.assign({ type: \"JsdocTypeGeneric\", left: assertRootResult(left), elements: objects }, infer ? { infer: true } : {}), { meta: {\n            brackets: \"angle\",\n            dot\n          } });\n        }, \"parseInfix\")\n      });\n      const unionParslet = composeParslet({\n        name: \"unionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"|\", \"accept\"),\n        precedence: Precedence.UNION,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"|\");\n          const elements = [];\n          do {\n            elements.push(parser.parseType(Precedence.UNION));\n          } while (parser.consume(\"|\"));\n          return {\n            type: \"JsdocTypeUnion\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }, \"parseInfix\")\n      });\n      const baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n          allowTrailingComma: true\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n      ];\n      function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar: pathGrammar2 }) {\n        return /* @__PURE__ */ __name(function namePathParslet(parser, precedence, left) {\n          if (left == null || precedence >= Precedence.NAME_PATH) {\n            return null;\n          }\n          const type = parser.lexer.current.type;\n          const next = parser.lexer.next.type;\n          const accept = type === \".\" && next !== \"<\" || type === \"[\" && (allowSquareBracketsOnAnyType || left.type === \"JsdocTypeName\") || allowJsdocNamePaths && (type === \"~\" || type === \"#\");\n          if (!accept) {\n            return null;\n          }\n          let pathType;\n          let brackets = false;\n          if (parser.consume(\".\")) {\n            pathType = \"property\";\n          } else if (parser.consume(\"[\")) {\n            pathType = \"property-brackets\";\n            brackets = true;\n          } else if (parser.consume(\"~\")) {\n            pathType = \"inner\";\n          } else {\n            parser.consume(\"#\");\n            pathType = \"instance\";\n          }\n          const pathParser = pathGrammar2 !== null ? new Parser(pathGrammar2, parser.lexer, parser) : parser;\n          const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n          parser.acceptLexerState(pathParser);\n          let right;\n          switch (parsed.type) {\n            case \"JsdocTypeName\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeNumber\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value.toString(10),\n                meta: {\n                  quote: void 0\n                }\n              };\n              break;\n            case \"JsdocTypeStringValue\":\n              right = {\n                type: \"JsdocTypeProperty\",\n                value: parsed.value,\n                meta: {\n                  quote: parsed.meta.quote\n                }\n              };\n              break;\n            case \"JsdocTypeSpecialNamePath\":\n              if (parsed.specialType === \"event\") {\n                right = parsed;\n              } else {\n                throw new UnexpectedTypeError(parsed, \"Type 'JsdocTypeSpecialNamePath' is only allowed with specialType 'event'\");\n              }\n              break;\n            default:\n              throw new UnexpectedTypeError(parsed, \"Expecting 'JsdocTypeName', 'JsdocTypeNumber', 'JsdocStringValue' or 'JsdocTypeSpecialNamePath'\");\n          }\n          if (brackets && !parser.consume(\"]\")) {\n            const token = parser.lexer.current;\n            throw new Error(`Unterminated square brackets. Next token is '${token.type}' with text '${token.text}'`);\n          }\n          return {\n            type: \"JsdocTypeNamePath\",\n            left: assertRootResult(left),\n            right,\n            pathType\n          };\n        }, \"namePathParslet\");\n      }\n      __name(createNamePathParslet, \"createNamePathParslet\");\n      function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n          name: \"nameParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"Identifier\" || type === \"this\" || type === \"new\" || allowedAdditionalTokens.includes(type), \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const { type, text } = parser.lexer.current;\n            parser.consume(type);\n            return {\n              type: \"JsdocTypeName\",\n              value: text\n            };\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createNameParslet, \"createNameParslet\");\n      const stringValueParslet = composeParslet({\n        name: \"stringValueParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"StringValue\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const text = parser.lexer.current.text;\n          parser.consume(\"StringValue\");\n          return {\n            type: \"JsdocTypeStringValue\",\n            value: text.slice(1, -1),\n            meta: {\n              quote: text[0] === \"'\" ? \"single\" : \"double\"\n            }\n          };\n        }, \"parsePrefix\")\n      });\n      function createSpecialNamePathParslet({ pathGrammar: pathGrammar2, allowedTypes }) {\n        return composeParslet({\n          name: \"specialNamePathParslet\",\n          accept: /* @__PURE__ */ __name((type) => allowedTypes.includes(type), \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const type = parser.lexer.current.type;\n            parser.consume(type);\n            if (!parser.consume(\":\")) {\n              return {\n                type: \"JsdocTypeName\",\n                value: type\n              };\n            }\n            let result;\n            let token = parser.lexer.current;\n            if (parser.consume(\"StringValue\")) {\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value: token.text.slice(1, -1),\n                specialType: type,\n                meta: {\n                  quote: token.text[0] === \"'\" ? \"single\" : \"double\"\n                }\n              };\n            } else {\n              let value = \"\";\n              const allowed = [\"Identifier\", \"@\", \"/\"];\n              while (allowed.some((type2) => parser.consume(type2))) {\n                value += token.text;\n                token = parser.lexer.current;\n              }\n              result = {\n                type: \"JsdocTypeSpecialNamePath\",\n                value,\n                specialType: type,\n                meta: {\n                  quote: void 0\n                }\n              };\n            }\n            const moduleParser = new Parser(pathGrammar2, parser.lexer, parser);\n            const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n            parser.acceptLexerState(moduleParser);\n            return assertRootResult(moduleResult);\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createSpecialNamePathParslet, \"createSpecialNamePathParslet\");\n      const basePathGrammar = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"external\", \"module\"]\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar: null\n        })\n      ];\n      const pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"event\"],\n          pathGrammar: basePathGrammar\n        })\n      ];\n      function getParameters(value) {\n        let parameters;\n        if (value.type === \"JsdocTypeParameterList\") {\n          parameters = value.elements;\n        } else if (value.type === \"JsdocTypeParenthesis\") {\n          parameters = [value.element];\n        } else {\n          throw new UnexpectedTypeError(value);\n        }\n        return parameters.map((p) => assertPlainKeyValueOrRootResult(p));\n      }\n      __name(getParameters, \"getParameters\");\n      function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some((p) => p.type === \"JsdocTypeKeyValue\")) {\n          throw new Error(\"No parameter should be named\");\n        }\n        return parameters;\n      }\n      __name(getUnnamedParameters, \"getUnnamedParameters\");\n      function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n          name: \"functionParslet\",\n          accept: /* @__PURE__ */ __name((type, next) => type === \"function\" || allowNewAsFunctionKeyword && type === \"new\" && next === \"(\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            const newKeyword = parser.consume(\"new\");\n            parser.consume(\"function\");\n            const hasParenthesis = parser.lexer.current.type === \"(\";\n            if (!hasParenthesis) {\n              if (!allowWithoutParenthesis) {\n                throw new Error(\"function is missing parameter list\");\n              }\n              return {\n                type: \"JsdocTypeName\",\n                value: \"function\"\n              };\n            }\n            let result = {\n              type: \"JsdocTypeFunction\",\n              parameters: [],\n              arrow: false,\n              constructor: newKeyword,\n              parenthesis: hasParenthesis\n            };\n            const value = parser.parseIntermediateType(Precedence.FUNCTION);\n            if (allowNamedParameters === void 0) {\n              result.parameters = getUnnamedParameters(value);\n            } else if (newKeyword && value.type === \"JsdocTypeFunction\" && value.arrow) {\n              result = value;\n              result.constructor = true;\n              return result;\n            } else {\n              result.parameters = getParameters(value);\n              for (const p of result.parameters) {\n                if (p.type === \"JsdocTypeKeyValue\" && !allowNamedParameters.includes(p.key)) {\n                  throw new Error(`only allowed named parameters are ${allowNamedParameters.join(\", \")} but got ${p.type}`);\n                }\n              }\n            }\n            if (parser.consume(\":\")) {\n              result.returnType = parser.parseType(Precedence.PREFIX);\n            } else {\n              if (!allowNoReturnType) {\n                throw new Error(\"function is missing return type\");\n              }\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createFunctionParslet, \"createFunctionParslet\");\n      function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n          name: \"variadicParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"...\", \"accept\"),\n          precedence: Precedence.PREFIX,\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"...\");\n            const brackets = allowEnclosingBrackets && parser.consume(\"[\");\n            try {\n              const element = parser.parseType(Precedence.PREFIX);\n              if (brackets && !parser.consume(\"]\")) {\n                throw new Error(\"Unterminated variadic type. Missing ']'\");\n              }\n              return {\n                type: \"JsdocTypeVariadic\",\n                element: assertRootResult(element),\n                meta: {\n                  position: \"prefix\",\n                  squareBrackets: brackets\n                }\n              };\n            } catch (e) {\n              if (e instanceof NoParsletFoundError) {\n                if (brackets) {\n                  throw new Error(\"Empty square brackets for variadic are not allowed.\");\n                }\n                return {\n                  type: \"JsdocTypeVariadic\",\n                  meta: {\n                    position: void 0,\n                    squareBrackets: false\n                  }\n                };\n              } else {\n                throw e;\n              }\n            }\n          }, \"parsePrefix\"),\n          parseInfix: allowPostfix ? (parser, left) => {\n            parser.consume(\"...\");\n            return {\n              type: \"JsdocTypeVariadic\",\n              element: assertRootResult(left),\n              meta: {\n                position: \"suffix\",\n                squareBrackets: false\n              }\n            };\n          } : void 0\n        });\n      }\n      __name(createVariadicParslet, \"createVariadicParslet\");\n      const symbolParslet = composeParslet({\n        name: \"symbolParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"(\", \"accept\"),\n        precedence: Precedence.SYMBOL,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          if (left.type !== \"JsdocTypeName\") {\n            throw new Error(\"Symbol expects a name on the left side. (Reacting on '(')\");\n          }\n          parser.consume(\"(\");\n          const result = {\n            type: \"JsdocTypeSymbol\",\n            value: left.value\n          };\n          if (!parser.consume(\")\")) {\n            const next = parser.parseIntermediateType(Precedence.SYMBOL);\n            result.element = assertNumberOrVariadicNameResult(next);\n            if (!parser.consume(\")\")) {\n              throw new Error(\"Symbol does not end after value\");\n            }\n          }\n          return result;\n        }, \"parseInfix\")\n      });\n      const arrayBracketsParslet = composeParslet({\n        name: \"arrayBracketsParslet\",\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: /* @__PURE__ */ __name((type, next) => type === \"[\" && next === \"]\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"[\");\n          parser.consume(\"]\");\n          return {\n            type: \"JsdocTypeGeneric\",\n            left: {\n              type: \"JsdocTypeName\",\n              value: \"Array\"\n            },\n            elements: [\n              assertRootResult(left)\n            ],\n            meta: {\n              brackets: \"square\",\n              dot: false\n            }\n          };\n        }, \"parseInfix\")\n      });\n      function createObjectParslet({ objectFieldGrammar: objectFieldGrammar2, allowKeyTypes }) {\n        return composeParslet({\n          name: \"objectParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"{\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"{\");\n            const result = {\n              type: \"JsdocTypeObject\",\n              meta: {\n                separator: \"comma\"\n              },\n              elements: []\n            };\n            if (!parser.consume(\"}\")) {\n              let separator;\n              const fieldParser = new Parser(objectFieldGrammar2, parser.lexer, parser);\n              while (true) {\n                fieldParser.acceptLexerState(parser);\n                let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                parser.acceptLexerState(fieldParser);\n                if (field === void 0 && allowKeyTypes) {\n                  field = parser.parseIntermediateType(Precedence.OBJECT);\n                }\n                let optional = false;\n                if (field.type === \"JsdocTypeNullable\") {\n                  optional = true;\n                  field = field.element;\n                }\n                if (field.type === \"JsdocTypeNumber\" || field.type === \"JsdocTypeName\" || field.type === \"JsdocTypeStringValue\") {\n                  let quote2;\n                  if (field.type === \"JsdocTypeStringValue\") {\n                    quote2 = field.meta.quote;\n                  }\n                  result.elements.push({\n                    type: \"JsdocTypeObjectField\",\n                    key: field.value.toString(),\n                    right: void 0,\n                    optional,\n                    readonly: false,\n                    meta: {\n                      quote: quote2\n                    }\n                  });\n                } else if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") {\n                  result.elements.push(field);\n                } else {\n                  throw new UnexpectedTypeError(field);\n                }\n                if (parser.lexer.current.startOfLine) {\n                  separator = \"linebreak\";\n                  parser.consume(\",\") || parser.consume(\";\");\n                } else if (parser.consume(\",\")) {\n                  separator = \"comma\";\n                } else if (parser.consume(\";\")) {\n                  separator = \"semicolon\";\n                } else {\n                  break;\n                }\n                const type = parser.lexer.current.type;\n                if (type === \"}\") {\n                  break;\n                }\n              }\n              result.meta.separator = separator !== null && separator !== void 0 ? separator : \"comma\";\n              if (separator === \"linebreak\") {\n                result.meta.propertyIndent = \"  \";\n              }\n              if (!parser.consume(\"}\")) {\n                throw new Error(\"Unterminated record type. Missing '}'\");\n              }\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createObjectParslet, \"createObjectParslet\");\n      function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n          name: \"objectFieldParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: /* @__PURE__ */ __name((type) => type === \":\", \"accept\"),\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            var _a;\n            let optional = false;\n            let readonlyProperty = false;\n            if (allowOptional && left.type === \"JsdocTypeNullable\") {\n              optional = true;\n              left = left.element;\n            }\n            if (allowReadonly && left.type === \"JsdocTypeReadonlyProperty\") {\n              readonlyProperty = true;\n              left = left.element;\n            }\n            const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n            parentParser.acceptLexerState(parser);\n            if (left.type === \"JsdocTypeNumber\" || left.type === \"JsdocTypeName\" || left.type === \"JsdocTypeStringValue\" || isSquaredProperty(left)) {\n              if (isSquaredProperty(left) && !allowSquaredProperties) {\n                throw new UnexpectedTypeError(left);\n              }\n              parentParser.consume(\":\");\n              let quote2;\n              if (left.type === \"JsdocTypeStringValue\") {\n                quote2 = left.meta.quote;\n              }\n              const right = parentParser.parseType(Precedence.KEY_VALUE);\n              parser.acceptLexerState(parentParser);\n              return {\n                type: \"JsdocTypeObjectField\",\n                key: isSquaredProperty(left) ? left : left.value.toString(),\n                right,\n                optional,\n                readonly: readonlyProperty,\n                meta: {\n                  quote: quote2\n                }\n              };\n            } else {\n              if (!allowKeyTypes) {\n                throw new UnexpectedTypeError(left);\n              }\n              parentParser.consume(\":\");\n              const right = parentParser.parseType(Precedence.KEY_VALUE);\n              parser.acceptLexerState(parentParser);\n              return {\n                type: \"JsdocTypeJsdocObjectField\",\n                left: assertRootResult(left),\n                right\n              };\n            }\n          }, \"parseInfix\")\n        });\n      }\n      __name(createObjectFieldParslet, \"createObjectFieldParslet\");\n      function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n          name: \"keyValueParslet\",\n          precedence: Precedence.KEY_VALUE,\n          accept: /* @__PURE__ */ __name((type) => type === \":\", \"accept\"),\n          parseInfix: /* @__PURE__ */ __name((parser, left) => {\n            let optional = false;\n            let variadic = false;\n            if (allowOptional && left.type === \"JsdocTypeNullable\") {\n              optional = true;\n              left = left.element;\n            }\n            if (allowVariadic && left.type === \"JsdocTypeVariadic\" && left.element !== void 0) {\n              variadic = true;\n              left = left.element;\n            }\n            if (left.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(left);\n            }\n            parser.consume(\":\");\n            const right = parser.parseType(Precedence.KEY_VALUE);\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: left.value,\n              right,\n              optional,\n              variadic\n            };\n          }, \"parseInfix\")\n        });\n      }\n      __name(createKeyValueParslet, \"createKeyValueParslet\");\n      const jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n          allowWithoutParenthesis: true,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: true,\n          allowNewAsFunctionKeyword: false\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\", \"external\", \"event\"],\n          pathGrammar\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: true,\n          allowPostfix: true\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar\n        })\n      ];\n      const jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n          // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n          // we leave out the object type deliberately\n          objectFieldGrammar: [\n            createNameParslet({\n              allowedAdditionalTokens: [\"typeof\", \"module\", \"in\"]\n            }),\n            createObjectFieldParslet({\n              allowSquaredProperties: false,\n              allowKeyTypes: true,\n              allowOptional: false,\n              allowReadonly: false\n            }),\n            ...jsdocBaseGrammar\n          ],\n          allowKeyTypes: true\n        }),\n        createKeyValueParslet({\n          allowOptional: true,\n          allowVariadic: true\n        })\n      ];\n      const typeOfParslet = composeParslet({\n        name: \"typeOfParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"typeof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"typeof\");\n          return {\n            type: \"JsdocTypeTypeof\",\n            element: parser.parseType(Precedence.KEY_OF_TYPE_OF)\n          };\n        }, \"parsePrefix\")\n      });\n      const objectFieldGrammar$1 = [\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: false,\n          allowKeyTypes: false,\n          allowOptional: false,\n          allowReadonly: false\n        })\n      ];\n      const closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: false,\n          objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: false,\n          allowNamedParameters: [\"this\", \"new\"],\n          allowNoReturnType: true,\n          allowNewAsFunctionKeyword: false\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: false,\n          allowPostfix: false\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n          allowedAdditionalTokens: [\"keyof\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: false,\n          allowJsdocNamePaths: true,\n          pathGrammar\n        }),\n        createKeyValueParslet({\n          allowOptional: false,\n          allowVariadic: false\n        }),\n        symbolParslet\n      ];\n      const assertsParslet = composeParslet({\n        name: \"assertsParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"asserts\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"asserts\");\n          const left = parser.parseIntermediateType(Precedence.SYMBOL);\n          if (left.type !== \"JsdocTypeName\") {\n            throw new UnexpectedTypeError(left, \"A typescript asserts always has to have a name on the left side.\");\n          }\n          if (!parser.consume(\"is\")) {\n            return {\n              type: \"JsdocTypeAssertsPlain\",\n              element: left\n            };\n          }\n          return {\n            type: \"JsdocTypeAsserts\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }, \"parsePrefix\")\n      });\n      function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n          name: \"tupleParslet\",\n          accept: /* @__PURE__ */ __name((type) => type === \"[\", \"accept\"),\n          parsePrefix: /* @__PURE__ */ __name((parser) => {\n            parser.consume(\"[\");\n            const result = {\n              type: \"JsdocTypeTuple\",\n              elements: []\n            };\n            if (parser.consume(\"]\")) {\n              return result;\n            }\n            const typeList = parser.parseIntermediateType(Precedence.ALL);\n            if (typeList.type === \"JsdocTypeParameterList\") {\n              if (typeList.elements[0].type === \"JsdocTypeKeyValue\") {\n                result.elements = typeList.elements.map(assertPlainKeyValueResult);\n              } else {\n                result.elements = typeList.elements.map(assertRootResult);\n              }\n            } else {\n              if (typeList.type === \"JsdocTypeKeyValue\") {\n                result.elements = [assertPlainKeyValueResult(typeList)];\n              } else {\n                result.elements = [assertRootResult(typeList)];\n              }\n            }\n            if (!parser.consume(\"]\")) {\n              throw new Error(\"Unterminated '['\");\n            }\n            if (result.elements.some((e) => e.type === \"JsdocTypeUnknown\")) {\n              throw new Error(\"Question mark in tuple not allowed\");\n            }\n            return result;\n          }, \"parsePrefix\")\n        });\n      }\n      __name(createTupleParslet, \"createTupleParslet\");\n      const keyOfParslet = composeParslet({\n        name: \"keyOfParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"keyof\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"keyof\");\n          return {\n            type: \"JsdocTypeKeyof\",\n            element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n          };\n        }, \"parsePrefix\")\n      });\n      const importParslet = composeParslet({\n        name: \"importParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"import\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"import\");\n          if (!parser.consume(\"(\")) {\n            throw new Error(\"Missing parenthesis after import keyword\");\n          }\n          const path = parser.parseType(Precedence.PREFIX);\n          if (path.type !== \"JsdocTypeStringValue\") {\n            throw new Error(\"Only string values are allowed as paths for imports\");\n          }\n          if (!parser.consume(\")\")) {\n            throw new Error(\"Missing closing parenthesis after import keyword\");\n          }\n          return {\n            type: \"JsdocTypeImport\",\n            element: path\n          };\n        }, \"parsePrefix\")\n      });\n      const readonlyPropertyParslet = composeParslet({\n        name: \"readonlyPropertyParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"readonly\");\n          return {\n            type: \"JsdocTypeReadonlyProperty\",\n            element: parser.parseIntermediateType(Precedence.KEY_VALUE)\n          };\n        }, \"parsePrefix\")\n      });\n      const arrowFunctionParslet = composeParslet({\n        name: \"arrowFunctionParslet\",\n        precedence: Precedence.ARROW,\n        accept: /* @__PURE__ */ __name((type) => type === \"=>\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"=>\");\n          return {\n            type: \"JsdocTypeFunction\",\n            parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n            arrow: true,\n            constructor: false,\n            parenthesis: true,\n            returnType: parser.parseType(Precedence.OBJECT)\n          };\n        }, \"parseInfix\")\n      });\n      const genericArrowFunctionParslet = composeParslet({\n        name: \"genericArrowFunctionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"<\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          const typeParameters = [];\n          parser.consume(\"<\");\n          do {\n            let defaultValue;\n            let name = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (name.type === \"JsdocTypeOptional\") {\n              name = name.element;\n              defaultValue = parser.parseType(Precedence.SYMBOL);\n            }\n            if (name.type !== \"JsdocTypeName\") {\n              throw new UnexpectedTypeError(name);\n            }\n            let constraint;\n            if (parser.consume(\"extends\")) {\n              constraint = parser.parseType(Precedence.SYMBOL);\n              if (constraint.type === \"JsdocTypeOptional\") {\n                constraint = constraint.element;\n                defaultValue = parser.parseType(Precedence.SYMBOL);\n              }\n            }\n            const typeParameter = {\n              type: \"JsdocTypeTypeParameter\",\n              name\n            };\n            if (constraint !== void 0) {\n              typeParameter.constraint = constraint;\n            }\n            if (defaultValue !== void 0) {\n              typeParameter.defaultValue = defaultValue;\n            }\n            typeParameters.push(typeParameter);\n            if (parser.consume(\">\")) {\n              break;\n            }\n          } while (parser.consume(\",\"));\n          const functionBase = parser.parseIntermediateType(Precedence.SYMBOL);\n          functionBase.typeParameters = typeParameters;\n          return functionBase;\n        }, \"parsePrefix\")\n      });\n      const intersectionParslet = composeParslet({\n        name: \"intersectionParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"&\", \"accept\"),\n        precedence: Precedence.INTERSECTION,\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"&\");\n          const elements = [];\n          do {\n            elements.push(parser.parseType(Precedence.INTERSECTION));\n          } while (parser.consume(\"&\"));\n          return {\n            type: \"JsdocTypeIntersection\",\n            elements: [assertRootResult(left), ...elements]\n          };\n        }, \"parseInfix\")\n      });\n      const predicateParslet = composeParslet({\n        name: \"predicateParslet\",\n        precedence: Precedence.INFIX,\n        accept: /* @__PURE__ */ __name((type) => type === \"is\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          if (left.type !== \"JsdocTypeName\") {\n            throw new UnexpectedTypeError(left, \"A typescript predicate always has to have a name on the left side.\");\n          }\n          parser.consume(\"is\");\n          return {\n            type: \"JsdocTypePredicate\",\n            left,\n            right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n          };\n        }, \"parseInfix\")\n      });\n      const objectSquaredPropertyParslet = composeParslet({\n        name: \"objectSquareBracketPropertyParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"[\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          if (parser.baseParser === void 0) {\n            throw new Error(\"Only allowed inside object grammar\");\n          }\n          parser.consume(\"[\");\n          const key = parser.lexer.current.text;\n          parser.consume(\"Identifier\");\n          let result;\n          if (parser.consume(\":\")) {\n            const parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser);\n            result = {\n              type: \"JsdocTypeIndexSignature\",\n              key,\n              right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n            };\n            parser.acceptLexerState(parentParser);\n          } else if (parser.consume(\"in\")) {\n            const parentParser = parser.baseParser;\n            parentParser.acceptLexerState(parser);\n            result = {\n              type: \"JsdocTypeMappedType\",\n              key,\n              right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n            };\n            parser.acceptLexerState(parentParser);\n          } else {\n            throw new Error(\"Missing ':' or 'in' inside square bracketed property.\");\n          }\n          if (!parser.consume(\"]\")) {\n            throw new Error(\"Unterminated square brackets\");\n          }\n          return result;\n        }, \"parsePrefix\")\n      });\n      const readonlyArrayParslet = composeParslet({\n        name: \"readonlyArrayParslet\",\n        accept: /* @__PURE__ */ __name((type) => type === \"readonly\", \"accept\"),\n        parsePrefix: /* @__PURE__ */ __name((parser) => {\n          parser.consume(\"readonly\");\n          return {\n            type: \"JsdocTypeReadonlyArray\",\n            element: assertArrayOrTupleResult(parser.parseIntermediateType(Precedence.ALL))\n          };\n        }, \"parsePrefix\")\n      });\n      const conditionalParslet = composeParslet({\n        name: \"conditionalParslet\",\n        precedence: Precedence.INFIX,\n        accept: /* @__PURE__ */ __name((type) => type === \"extends\", \"accept\"),\n        parseInfix: /* @__PURE__ */ __name((parser, left) => {\n          parser.consume(\"extends\");\n          const extendsType = parser.parseType(Precedence.KEY_OF_TYPE_OF).element;\n          const trueType = parser.parseType(Precedence.INFIX);\n          parser.consume(\":\");\n          return {\n            type: \"JsdocTypeConditional\",\n            checksType: assertRootResult(left),\n            extendsType,\n            trueType,\n            falseType: parser.parseType(Precedence.INFIX)\n          };\n        }, \"parseInfix\")\n      });\n      const objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"typeof\", \"module\", \"keyof\", \"event\", \"external\", \"in\"]\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n          allowSquaredProperties: true,\n          allowKeyTypes: false,\n          allowOptional: true,\n          allowReadonly: true\n        }),\n        objectSquaredPropertyParslet\n      ];\n      const typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n          allowKeyTypes: false,\n          objectFieldGrammar\n        }),\n        readonlyArrayParslet,\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n          allowWithoutParenthesis: true,\n          allowNoReturnType: false,\n          allowNamedParameters: [\"this\", \"new\", \"args\"],\n          allowNewAsFunctionKeyword: true\n        }),\n        createTupleParslet({\n          allowQuestionMark: false\n        }),\n        createVariadicParslet({\n          allowEnclosingBrackets: false,\n          allowPostfix: false\n        }),\n        assertsParslet,\n        conditionalParslet,\n        createNameParslet({\n          allowedAdditionalTokens: [\"event\", \"external\", \"in\"]\n        }),\n        createSpecialNamePathParslet({\n          allowedTypes: [\"module\"],\n          pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        genericArrowFunctionParslet,\n        createNamePathParslet({\n          allowSquareBracketsOnAnyType: true,\n          allowJsdocNamePaths: false,\n          pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n          allowVariadic: true,\n          allowOptional: true\n        })\n      ];\n      function parse3(expression, mode) {\n        switch (mode) {\n          case \"closure\":\n            return new Parser(closureGrammar, expression).parse();\n          case \"jsdoc\":\n            return new Parser(jsdocGrammar, expression).parse();\n          case \"typescript\":\n            return new Parser(typescriptGrammar, expression).parse();\n        }\n      }\n      __name(parse3, \"parse\");\n      function tryParse(expression, modes = [\"typescript\", \"closure\", \"jsdoc\"]) {\n        let error;\n        for (const mode of modes) {\n          try {\n            return parse3(expression, mode);\n          } catch (e) {\n            error = e;\n          }\n        }\n        throw error;\n      }\n      __name(tryParse, \"tryParse\");\n      function transform(rules2, parseResult) {\n        const rule = rules2[parseResult.type];\n        if (rule === void 0) {\n          throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, (aParseResult) => transform(rules2, aParseResult));\n      }\n      __name(transform, \"transform\");\n      function notAvailableTransform(parseResult) {\n        throw new Error(\"This transform is not available. Are you trying the correct parsing mode?\");\n      }\n      __name(notAvailableTransform, \"notAvailableTransform\");\n      function extractSpecialParams(source) {\n        const result = {\n          params: []\n        };\n        for (const param of source.parameters) {\n          if (param.type === \"JsdocTypeKeyValue\") {\n            if (param.key === \"this\") {\n              result.this = param.right;\n            } else if (param.key === \"new\") {\n              result.new = param.right;\n            } else {\n              result.params.push(param);\n            }\n          } else {\n            result.params.push(param);\n          }\n        }\n        return result;\n      }\n      __name(extractSpecialParams, \"extractSpecialParams\");\n      function applyPosition(position, target, value) {\n        return position === \"prefix\" ? value + target : target + value;\n      }\n      __name(applyPosition, \"applyPosition\");\n      function quote(value, quote2) {\n        switch (quote2) {\n          case \"double\":\n            return `\"${value}\"`;\n          case \"single\":\n            return `'${value}'`;\n          case void 0:\n            return value;\n        }\n      }\n      __name(quote, \"quote\");\n      function stringifyRules2() {\n        return {\n          JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => `(${result.element !== void 0 ? transform2(result.element) : \"\"})`, \"JsdocTypeParenthesis\"),\n          JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => `keyof ${transform2(result.element)}`, \"JsdocTypeKeyof\"),\n          JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n            var _a;\n            if (!result.arrow) {\n              let stringified = result.constructor ? \"new\" : \"function\";\n              if (!result.parenthesis) {\n                return stringified;\n              }\n              stringified += `(${result.parameters.map(transform2).join(\", \")})`;\n              if (result.returnType !== void 0) {\n                stringified += `: ${transform2(result.returnType)}`;\n              }\n              return stringified;\n            } else {\n              if (result.returnType === void 0) {\n                throw new Error(\"Arrow function needs a return type.\");\n              }\n              let stringified = `${result.typeParameters !== void 0 ? `<${(_a = result.typeParameters.map(transform2).join(\", \")) !== null && _a !== void 0 ? _a : \"\"}>` : \"\"}(${result.parameters.map(transform2).join(\", \")}) => ${transform2(result.returnType)}`;\n              if (result.constructor) {\n                stringified = \"new \" + stringified;\n              }\n              return stringified;\n            }\n          }, \"JsdocTypeFunction\"),\n          JsdocTypeName: /* @__PURE__ */ __name((result) => result.value, \"JsdocTypeName\"),\n          JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => `[${result.elements.map(transform2).join(\", \")}]`, \"JsdocTypeTuple\"),\n          JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => result.meta.position === void 0 ? \"...\" : applyPosition(result.meta.position, transform2(result.element), \"...\"), \"JsdocTypeVariadic\"),\n          JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n            const left = transform2(result.left);\n            const right = transform2(result.right);\n            switch (result.pathType) {\n              case \"inner\":\n                return `${left}~${right}`;\n              case \"instance\":\n                return `${left}#${right}`;\n              case \"property\":\n                return `${left}.${right}`;\n              case \"property-brackets\":\n                return `${left}[${right}]`;\n            }\n          }, \"JsdocTypeNamePath\"),\n          JsdocTypeStringValue: /* @__PURE__ */ __name((result) => quote(result.value, result.meta.quote), \"JsdocTypeStringValue\"),\n          JsdocTypeAny: /* @__PURE__ */ __name(() => \"*\", \"JsdocTypeAny\"),\n          JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => {\n            if (result.meta.brackets === \"square\") {\n              const element = result.elements[0];\n              const transformed = transform2(element);\n              if (element.type === \"JsdocTypeUnion\" || element.type === \"JsdocTypeIntersection\") {\n                return `(${transformed})[]`;\n              } else {\n                return `${transformed}[]`;\n              }\n            } else {\n              return `${transform2(result.left)}${result.meta.dot ? \".\" : \"\"}<${result.infer === true ? \"infer \" : \"\"}${result.elements.map(transform2).join(\", \")}>`;\n            }\n          }, \"JsdocTypeGeneric\"),\n          JsdocTypeImport: /* @__PURE__ */ __name((result, transform2) => `import(${transform2(result.element)})`, \"JsdocTypeImport\"),\n          JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n            let text = \"\";\n            if (result.readonly) {\n              text += \"readonly \";\n            }\n            if (typeof result.key === \"string\") {\n              text += quote(result.key, result.meta.quote);\n            } else {\n              text += transform2(result.key);\n            }\n            if (result.optional) {\n              text += \"?\";\n            }\n            if (result.right === void 0) {\n              return text;\n            } else {\n              return text + `: ${transform2(result.right)}`;\n            }\n          }, \"JsdocTypeObjectField\"),\n          JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => {\n            return `${transform2(result.left)}: ${transform2(result.right)}`;\n          }, \"JsdocTypeJsdocObjectField\"),\n          JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n            let text = result.key;\n            if (result.optional) {\n              text += \"?\";\n            }\n            if (result.variadic) {\n              text = \"...\" + text;\n            }\n            if (result.right === void 0) {\n              return text;\n            } else {\n              return text + `: ${transform2(result.right)}`;\n            }\n          }, \"JsdocTypeKeyValue\"),\n          JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => `${result.specialType}:${quote(result.value, result.meta.quote)}`, \"JsdocTypeSpecialNamePath\"),\n          JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"!\"), \"JsdocTypeNotNullable\"),\n          JsdocTypeNull: /* @__PURE__ */ __name(() => \"null\", \"JsdocTypeNull\"),\n          JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"?\"), \"JsdocTypeNullable\"),\n          JsdocTypeNumber: /* @__PURE__ */ __name((result) => result.value.toString(), \"JsdocTypeNumber\"),\n          JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n            var _a, _b;\n            return `{${(result.meta.separator === \"linebreak\" && result.elements.length > 1 ? \"\\n\" + ((_a = result.meta.propertyIndent) !== null && _a !== void 0 ? _a : \"\") : \"\") + result.elements.map(transform2).join(result.meta.separator === \"comma\" ? \", \" : result.meta.separator === \"linebreak\" ? \"\\n\" + ((_b = result.meta.propertyIndent) !== null && _b !== void 0 ? _b : \"\") : \"; \") + (result.meta.separator === \"linebreak\" && result.elements.length > 1 ? \"\\n\" : \"\")}}`;\n          }, \"JsdocTypeObject\"),\n          JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => applyPosition(result.meta.position, transform2(result.element), \"=\"), \"JsdocTypeOptional\"),\n          JsdocTypeSymbol: /* @__PURE__ */ __name((result, transform2) => `${result.value}(${result.element !== void 0 ? transform2(result.element) : \"\"})`, \"JsdocTypeSymbol\"),\n          JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => `typeof ${transform2(result.element)}`, \"JsdocTypeTypeof\"),\n          JsdocTypeUndefined: /* @__PURE__ */ __name(() => \"undefined\", \"JsdocTypeUndefined\"),\n          JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => result.elements.map(transform2).join(\" | \"), \"JsdocTypeUnion\"),\n          JsdocTypeUnknown: /* @__PURE__ */ __name(() => \"?\", \"JsdocTypeUnknown\"),\n          JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => result.elements.map(transform2).join(\" & \"), \"JsdocTypeIntersection\"),\n          JsdocTypeProperty: /* @__PURE__ */ __name((result) => quote(result.value, result.meta.quote), \"JsdocTypeProperty\"),\n          JsdocTypePredicate: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.left)} is ${transform2(result.right)}`, \"JsdocTypePredicate\"),\n          JsdocTypeIndexSignature: /* @__PURE__ */ __name((result, transform2) => `[${result.key}: ${transform2(result.right)}]`, \"JsdocTypeIndexSignature\"),\n          JsdocTypeMappedType: /* @__PURE__ */ __name((result, transform2) => `[${result.key} in ${transform2(result.right)}]`, \"JsdocTypeMappedType\"),\n          JsdocTypeAsserts: /* @__PURE__ */ __name((result, transform2) => `asserts ${transform2(result.left)} is ${transform2(result.right)}`, \"JsdocTypeAsserts\"),\n          JsdocTypeReadonlyArray: /* @__PURE__ */ __name((result, transform2) => `readonly ${transform2(result.element)}`, \"JsdocTypeReadonlyArray\"),\n          JsdocTypeAssertsPlain: /* @__PURE__ */ __name((result, transform2) => `asserts ${transform2(result.element)}`, \"JsdocTypeAssertsPlain\"),\n          JsdocTypeConditional: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.checksType)} extends ${transform2(result.extendsType)} ? ${transform2(result.trueType)} : ${transform2(result.falseType)}`, \"JsdocTypeConditional\"),\n          JsdocTypeTypeParameter: /* @__PURE__ */ __name((result, transform2) => `${transform2(result.name)}${result.constraint !== void 0 ? ` extends ${transform2(result.constraint)}` : \"\"}${result.defaultValue !== void 0 ? ` = ${transform2(result.defaultValue)}` : \"\"}`, \"JsdocTypeTypeParameter\")\n        };\n      }\n      __name(stringifyRules2, \"stringifyRules\");\n      const storedStringifyRules = stringifyRules2();\n      function stringify2(result) {\n        return transform(storedStringifyRules, result);\n      }\n      __name(stringify2, \"stringify\");\n      const reservedWords = [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"class\",\n        \"const\",\n        \"continue\",\n        \"debugger\",\n        \"default\",\n        \"delete\",\n        \"do\",\n        \"else\",\n        \"export\",\n        \"extends\",\n        \"finally\",\n        \"for\",\n        \"function\",\n        \"if\",\n        \"import\",\n        \"in\",\n        \"instanceof\",\n        \"new\",\n        \"return\",\n        \"super\",\n        \"switch\",\n        \"this\",\n        \"throw\",\n        \"try\",\n        \"typeof\",\n        \"var\",\n        \"void\",\n        \"while\",\n        \"with\",\n        \"yield\"\n      ];\n      function makeName(value) {\n        const result = {\n          type: \"NameExpression\",\n          name: value\n        };\n        if (reservedWords.includes(value)) {\n          result.reservedWord = true;\n        }\n        return result;\n      }\n      __name(makeName, \"makeName\");\n      const catharsisTransformRules = {\n        JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.optional = true;\n          return transformed;\n        }, \"JsdocTypeOptional\"),\n        JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.nullable = true;\n          return transformed;\n        }, \"JsdocTypeNullable\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = transform2(result.element);\n          transformed.nullable = false;\n          return transformed;\n        }, \"JsdocTypeNotNullable\"),\n        JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n          if (result.element === void 0) {\n            throw new Error(\"dots without value are not allowed in catharsis mode\");\n          }\n          const transformed = transform2(result.element);\n          transformed.repeatable = true;\n          return transformed;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeAny: /* @__PURE__ */ __name(() => ({\n          type: \"AllLiteral\"\n        }), \"JsdocTypeAny\"),\n        JsdocTypeNull: /* @__PURE__ */ __name(() => ({\n          type: \"NullLiteral\"\n        }), \"JsdocTypeNull\"),\n        JsdocTypeStringValue: /* @__PURE__ */ __name((result) => makeName(quote(result.value, result.meta.quote)), \"JsdocTypeStringValue\"),\n        JsdocTypeUndefined: /* @__PURE__ */ __name(() => ({\n          type: \"UndefinedLiteral\"\n        }), \"JsdocTypeUndefined\"),\n        JsdocTypeUnknown: /* @__PURE__ */ __name(() => ({\n          type: \"UnknownLiteral\"\n        }), \"JsdocTypeUnknown\"),\n        JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n          const params = extractSpecialParams(result);\n          const transformed = {\n            type: \"FunctionType\",\n            params: params.params.map(transform2)\n          };\n          if (params.this !== void 0) {\n            transformed.this = transform2(params.this);\n          }\n          if (params.new !== void 0) {\n            transformed.new = transform2(params.new);\n          }\n          if (result.returnType !== void 0) {\n            transformed.result = transform2(result.returnType);\n          }\n          return transformed;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TypeApplication\",\n          applications: result.elements.map((o) => transform2(o)),\n          expression: transform2(result.left)\n        }), \"JsdocTypeGeneric\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => makeName(result.specialType + \":\" + quote(result.value, result.meta.quote)), \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeName: /* @__PURE__ */ __name((result) => {\n          if (result.value !== \"function\") {\n            return makeName(result.value);\n          } else {\n            return {\n              type: \"FunctionType\",\n              params: []\n            };\n          }\n        }, \"JsdocTypeName\"),\n        JsdocTypeNumber: /* @__PURE__ */ __name((result) => makeName(result.value.toString()), \"JsdocTypeNumber\"),\n        JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"RecordType\",\n            fields: []\n          };\n          for (const field of result.elements) {\n            if (field.type !== \"JsdocTypeObjectField\" && field.type !== \"JsdocTypeJsdocObjectField\") {\n              transformed.fields.push({\n                type: \"FieldType\",\n                key: transform2(field),\n                value: void 0\n              });\n            } else {\n              transformed.fields.push(transform2(field));\n            }\n          }\n          return transformed;\n        }, \"JsdocTypeObject\"),\n        JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n          if (typeof result.key !== \"string\") {\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          }\n          return {\n            type: \"FieldType\",\n            key: makeName(quote(result.key, result.meta.quote)),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"FieldType\",\n          key: transform2(result.left),\n          value: transform2(result.right)\n        }), \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TypeUnion\",\n          elements: result.elements.map((e) => transform2(e))\n        }), \"JsdocTypeUnion\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n          return {\n            type: \"FieldType\",\n            key: makeName(result.key),\n            value: result.right === void 0 ? void 0 : transform2(result.right)\n          };\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n          const leftResult = transform2(result.left);\n          let rightValue;\n          if (result.right.type === \"JsdocTypeSpecialNamePath\") {\n            rightValue = transform2(result.right).name;\n          } else {\n            rightValue = quote(result.right.value, result.right.meta.quote);\n          }\n          const joiner = result.pathType === \"inner\" ? \"~\" : result.pathType === \"instance\" ? \"#\" : \".\";\n          return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeSymbol: /* @__PURE__ */ __name((result) => {\n          let value = \"\";\n          let element = result.element;\n          let trailingDots = false;\n          if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeVariadic\") {\n            if (element.meta.position === \"prefix\") {\n              value = \"...\";\n            } else {\n              trailingDots = true;\n            }\n            element = element.element;\n          }\n          if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeName\") {\n            value += element.value;\n          } else if ((element === null || element === void 0 ? void 0 : element.type) === \"JsdocTypeNumber\") {\n            value += element.value.toString();\n          }\n          if (trailingDots) {\n            value += \"...\";\n          }\n          return makeName(`${result.value}(${value})`);\n        }, \"JsdocTypeSymbol\"),\n        JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => transform2(assertRootResult(result.element)), \"JsdocTypeParenthesis\"),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n      }\n      __name(catharsisTransform, \"catharsisTransform\");\n      function getQuoteStyle(quote2) {\n        switch (quote2) {\n          case void 0:\n            return \"none\";\n          case \"single\":\n            return \"single\";\n          case \"double\":\n            return \"double\";\n        }\n      }\n      __name(getQuoteStyle, \"getQuoteStyle\");\n      function getMemberType(type) {\n        switch (type) {\n          case \"inner\":\n            return \"INNER_MEMBER\";\n          case \"instance\":\n            return \"INSTANCE_MEMBER\";\n          case \"property\":\n            return \"MEMBER\";\n          case \"property-brackets\":\n            return \"MEMBER\";\n        }\n      }\n      __name(getMemberType, \"getMemberType\");\n      function nestResults(type, results) {\n        if (results.length === 2) {\n          return {\n            type,\n            left: results[0],\n            right: results[1]\n          };\n        } else {\n          return {\n            type,\n            left: results[0],\n            right: nestResults(type, results.slice(1))\n          };\n        }\n      }\n      __name(nestResults, \"nestResults\");\n      const jtpRules = {\n        JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"OPTIONAL\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_EQUAL_SIGN\" : \"SUFFIX_EQUALS_SIGN\"\n          }\n        }), \"JsdocTypeOptional\"),\n        JsdocTypeNullable: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_QUESTION_MARK\" : \"SUFFIX_QUESTION_MARK\"\n          }\n        }), \"JsdocTypeNullable\"),\n        JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"NOT_NULLABLE\",\n          value: transform2(result.element),\n          meta: {\n            syntax: result.meta.position === \"prefix\" ? \"PREFIX_BANG\" : \"SUFFIX_BANG\"\n          }\n        }), \"JsdocTypeNotNullable\"),\n        JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"VARIADIC\",\n            meta: {\n              syntax: result.meta.position === \"prefix\" ? \"PREFIX_DOTS\" : result.meta.position === \"suffix\" ? \"SUFFIX_DOTS\" : \"ONLY_DOTS\"\n            }\n          };\n          if (result.element !== void 0) {\n            transformed.value = transform2(result.element);\n          }\n          return transformed;\n        }, \"JsdocTypeVariadic\"),\n        JsdocTypeName: /* @__PURE__ */ __name((result) => ({\n          type: \"NAME\",\n          name: result.value\n        }), \"JsdocTypeName\"),\n        JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TYPE_QUERY\",\n          name: transform2(result.element)\n        }), \"JsdocTypeTypeof\"),\n        JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"TUPLE\",\n          entries: result.elements.map(transform2)\n        }), \"JsdocTypeTuple\"),\n        JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"KEY_QUERY\",\n          value: transform2(result.element)\n        }), \"JsdocTypeKeyof\"),\n        JsdocTypeImport: /* @__PURE__ */ __name((result) => ({\n          type: \"IMPORT\",\n          path: {\n            type: \"STRING_VALUE\",\n            quoteStyle: getQuoteStyle(result.element.meta.quote),\n            string: result.element.value\n          }\n        }), \"JsdocTypeImport\"),\n        JsdocTypeUndefined: /* @__PURE__ */ __name(() => ({\n          type: \"NAME\",\n          name: \"undefined\"\n        }), \"JsdocTypeUndefined\"),\n        JsdocTypeAny: /* @__PURE__ */ __name(() => ({\n          type: \"ANY\"\n        }), \"JsdocTypeAny\"),\n        JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n          const specialParams = extractSpecialParams(result);\n          const transformed = {\n            type: result.arrow ? \"ARROW\" : \"FUNCTION\",\n            params: specialParams.params.map((param) => {\n              if (param.type === \"JsdocTypeKeyValue\") {\n                if (param.right === void 0) {\n                  throw new Error(\"Function parameter without ':' is not expected to be 'KEY_VALUE'\");\n                }\n                return {\n                  type: \"NAMED_PARAMETER\",\n                  name: param.key,\n                  typeName: transform2(param.right)\n                };\n              } else {\n                return transform2(param);\n              }\n            }),\n            new: null,\n            returns: null\n          };\n          if (specialParams.this !== void 0) {\n            transformed.this = transform2(specialParams.this);\n          } else if (!result.arrow) {\n            transformed.this = null;\n          }\n          if (specialParams.new !== void 0) {\n            transformed.new = transform2(specialParams.new);\n          }\n          if (result.returnType !== void 0) {\n            transformed.returns = transform2(result.returnType);\n          }\n          return transformed;\n        }, \"JsdocTypeFunction\"),\n        JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => {\n          const transformed = {\n            type: \"GENERIC\",\n            subject: transform2(result.left),\n            objects: result.elements.map(transform2),\n            meta: {\n              syntax: result.meta.brackets === \"square\" ? \"SQUARE_BRACKET\" : result.meta.dot ? \"ANGLE_BRACKET_WITH_DOT\" : \"ANGLE_BRACKET\"\n            }\n          };\n          if (result.meta.brackets === \"square\" && result.elements[0].type === \"JsdocTypeFunction\" && !result.elements[0].parenthesis) {\n            transformed.objects[0] = {\n              type: \"NAME\",\n              name: \"function\"\n            };\n          }\n          return transformed;\n        }, \"JsdocTypeGeneric\"),\n        JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => {\n          if (typeof result.key !== \"string\") {\n            throw new Error(\"Index signatures and mapped types are not supported\");\n          }\n          if (result.right === void 0) {\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              value: null,\n              readonly: false\n            };\n          }\n          let right = transform2(result.right);\n          if (result.optional) {\n            right = {\n              type: \"OPTIONAL\",\n              value: right,\n              meta: {\n                syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n              }\n            };\n          }\n          return {\n            type: \"RECORD_ENTRY\",\n            key: result.key.toString(),\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            value: right,\n            readonly: false\n          };\n        }, \"JsdocTypeObjectField\"),\n        JsdocTypeJsdocObjectField: /* @__PURE__ */ __name(() => {\n          throw new Error(\"Keys may not be typed in jsdoctypeparser.\");\n        }, \"JsdocTypeJsdocObjectField\"),\n        JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n          if (result.right === void 0) {\n            return {\n              type: \"RECORD_ENTRY\",\n              key: result.key,\n              quoteStyle: \"none\",\n              value: null,\n              readonly: false\n            };\n          }\n          let right = transform2(result.right);\n          if (result.optional) {\n            right = {\n              type: \"OPTIONAL\",\n              value: right,\n              meta: {\n                syntax: \"SUFFIX_KEY_QUESTION_MARK\"\n              }\n            };\n          }\n          return {\n            type: \"RECORD_ENTRY\",\n            key: result.key,\n            quoteStyle: \"none\",\n            value: right,\n            readonly: false\n          };\n        }, \"JsdocTypeKeyValue\"),\n        JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => {\n          const entries = [];\n          for (const field of result.elements) {\n            if (field.type === \"JsdocTypeObjectField\" || field.type === \"JsdocTypeJsdocObjectField\") {\n              entries.push(transform2(field));\n            }\n          }\n          return {\n            type: \"RECORD\",\n            entries\n          };\n        }, \"JsdocTypeObject\"),\n        JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => {\n          if (result.specialType !== \"module\") {\n            throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n          }\n          return {\n            type: \"MODULE\",\n            value: {\n              type: \"FILE_PATH\",\n              quoteStyle: getQuoteStyle(result.meta.quote),\n              path: result.value\n            }\n          };\n        }, \"JsdocTypeSpecialNamePath\"),\n        JsdocTypeNamePath: /* @__PURE__ */ __name((result, transform2) => {\n          let hasEventPrefix = false;\n          let name;\n          let quoteStyle;\n          if (result.right.type === \"JsdocTypeSpecialNamePath\" && result.right.specialType === \"event\") {\n            hasEventPrefix = true;\n            name = result.right.value;\n            quoteStyle = getQuoteStyle(result.right.meta.quote);\n          } else {\n            name = result.right.value;\n            quoteStyle = getQuoteStyle(result.right.meta.quote);\n          }\n          const transformed = {\n            type: getMemberType(result.pathType),\n            owner: transform2(result.left),\n            name,\n            quoteStyle,\n            hasEventPrefix\n          };\n          if (transformed.owner.type === \"MODULE\") {\n            const tModule = transformed.owner;\n            transformed.owner = transformed.owner.value;\n            tModule.value = transformed;\n            return tModule;\n          } else {\n            return transformed;\n          }\n        }, \"JsdocTypeNamePath\"),\n        JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => nestResults(\"UNION\", result.elements.map(transform2)), \"JsdocTypeUnion\"),\n        JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => ({\n          type: \"PARENTHESIS\",\n          value: transform2(assertRootResult(result.element))\n        }), \"JsdocTypeParenthesis\"),\n        JsdocTypeNull: /* @__PURE__ */ __name(() => ({\n          type: \"NAME\",\n          name: \"null\"\n        }), \"JsdocTypeNull\"),\n        JsdocTypeUnknown: /* @__PURE__ */ __name(() => ({\n          type: \"UNKNOWN\"\n        }), \"JsdocTypeUnknown\"),\n        JsdocTypeStringValue: /* @__PURE__ */ __name((result) => ({\n          type: \"STRING_VALUE\",\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          string: result.value\n        }), \"JsdocTypeStringValue\"),\n        JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => nestResults(\"INTERSECTION\", result.elements.map(transform2)), \"JsdocTypeIntersection\"),\n        JsdocTypeNumber: /* @__PURE__ */ __name((result) => ({\n          type: \"NUMBER_VALUE\",\n          number: result.value.toString()\n        }), \"JsdocTypeNumber\"),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform,\n        JsdocTypeReadonlyArray: notAvailableTransform,\n        JsdocTypeAssertsPlain: notAvailableTransform,\n        JsdocTypeConditional: notAvailableTransform,\n        JsdocTypeTypeParameter: notAvailableTransform\n      };\n      function jtpTransform(result) {\n        return transform(jtpRules, result);\n      }\n      __name(jtpTransform, \"jtpTransform\");\n      function identityTransformRules() {\n        return {\n          JsdocTypeIntersection: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeIntersection\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeIntersection\"),\n          JsdocTypeGeneric: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeGeneric\",\n            left: transform2(result.left),\n            elements: result.elements.map(transform2),\n            meta: {\n              dot: result.meta.dot,\n              brackets: result.meta.brackets\n            }\n          }), \"JsdocTypeGeneric\"),\n          JsdocTypeNullable: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNullable\"),\n          JsdocTypeUnion: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeUnion\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeUnion\"),\n          JsdocTypeUnknown: /* @__PURE__ */ __name((result) => result, \"JsdocTypeUnknown\"),\n          JsdocTypeUndefined: /* @__PURE__ */ __name((result) => result, \"JsdocTypeUndefined\"),\n          JsdocTypeTypeof: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTypeof\",\n            element: transform2(result.element)\n          }), \"JsdocTypeTypeof\"),\n          JsdocTypeSymbol: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeSymbol\",\n              value: result.value\n            };\n            if (result.element !== void 0) {\n              transformed.element = transform2(result.element);\n            }\n            return transformed;\n          }, \"JsdocTypeSymbol\"),\n          JsdocTypeOptional: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeOptional\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }), \"JsdocTypeOptional\"),\n          JsdocTypeObject: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeObject\",\n            meta: {\n              separator: \"comma\"\n            },\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeObject\"),\n          JsdocTypeNumber: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNumber\"),\n          JsdocTypeNull: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNull\"),\n          JsdocTypeNotNullable: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeNotNullable\",\n            element: transform2(result.element),\n            meta: {\n              position: result.meta.position\n            }\n          }), \"JsdocTypeNotNullable\"),\n          JsdocTypeSpecialNamePath: /* @__PURE__ */ __name((result) => result, \"JsdocTypeSpecialNamePath\"),\n          JsdocTypeObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeObjectField\",\n            key: result.key,\n            right: result.right === void 0 ? void 0 : transform2(result.right),\n            optional: result.optional,\n            readonly: result.readonly,\n            meta: result.meta\n          }), \"JsdocTypeObjectField\"),\n          JsdocTypeJsdocObjectField: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeJsdocObjectField\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypeJsdocObjectField\"),\n          JsdocTypeKeyValue: /* @__PURE__ */ __name((result, transform2) => {\n            return {\n              type: \"JsdocTypeKeyValue\",\n              key: result.key,\n              right: result.right === void 0 ? void 0 : transform2(result.right),\n              optional: result.optional,\n              variadic: result.variadic\n            };\n          }, \"JsdocTypeKeyValue\"),\n          JsdocTypeImport: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeImport\",\n            element: transform2(result.element)\n          }), \"JsdocTypeImport\"),\n          JsdocTypeAny: /* @__PURE__ */ __name((result) => result, \"JsdocTypeAny\"),\n          JsdocTypeStringValue: /* @__PURE__ */ __name((result) => result, \"JsdocTypeStringValue\"),\n          JsdocTypeNamePath: /* @__PURE__ */ __name((result) => result, \"JsdocTypeNamePath\"),\n          JsdocTypeVariadic: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeVariadic\",\n              meta: {\n                position: result.meta.position,\n                squareBrackets: result.meta.squareBrackets\n              }\n            };\n            if (result.element !== void 0) {\n              transformed.element = transform2(result.element);\n            }\n            return transformed;\n          }, \"JsdocTypeVariadic\"),\n          JsdocTypeTuple: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTuple\",\n            elements: result.elements.map(transform2)\n          }), \"JsdocTypeTuple\"),\n          JsdocTypeName: /* @__PURE__ */ __name((result) => result, \"JsdocTypeName\"),\n          JsdocTypeFunction: /* @__PURE__ */ __name((result, transform2) => {\n            const transformed = {\n              type: \"JsdocTypeFunction\",\n              arrow: result.arrow,\n              parameters: result.parameters.map(transform2),\n              constructor: result.constructor,\n              parenthesis: result.parenthesis\n            };\n            if (result.returnType !== void 0) {\n              transformed.returnType = transform2(result.returnType);\n            }\n            return transformed;\n          }, \"JsdocTypeFunction\"),\n          JsdocTypeKeyof: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeKeyof\",\n            element: transform2(result.element)\n          }), \"JsdocTypeKeyof\"),\n          JsdocTypeParenthesis: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeParenthesis\",\n            element: transform2(result.element)\n          }), \"JsdocTypeParenthesis\"),\n          JsdocTypeProperty: /* @__PURE__ */ __name((result) => result, \"JsdocTypeProperty\"),\n          JsdocTypePredicate: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypePredicate\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypePredicate\"),\n          JsdocTypeIndexSignature: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeIndexSignature\",\n            key: result.key,\n            right: transform2(result.right)\n          }), \"JsdocTypeIndexSignature\"),\n          JsdocTypeMappedType: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeMappedType\",\n            key: result.key,\n            right: transform2(result.right)\n          }), \"JsdocTypeMappedType\"),\n          JsdocTypeAsserts: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeAsserts\",\n            left: transform2(result.left),\n            right: transform2(result.right)\n          }), \"JsdocTypeAsserts\"),\n          JsdocTypeReadonlyArray: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeReadonlyArray\",\n            element: transform2(result.element)\n          }), \"JsdocTypeReadonlyArray\"),\n          JsdocTypeAssertsPlain: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeAssertsPlain\",\n            element: transform2(result.element)\n          }), \"JsdocTypeAssertsPlain\"),\n          JsdocTypeConditional: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeConditional\",\n            checksType: transform2(result.checksType),\n            extendsType: transform2(result.extendsType),\n            trueType: transform2(result.trueType),\n            falseType: transform2(result.falseType)\n          }), \"JsdocTypeConditional\"),\n          JsdocTypeTypeParameter: /* @__PURE__ */ __name((result, transform2) => ({\n            type: \"JsdocTypeTypeParameter\",\n            name: transform2(result.name),\n            constraint: result.constraint !== void 0 ? transform2(result.constraint) : void 0,\n            defaultValue: result.defaultValue !== void 0 ? transform2(result.defaultValue) : void 0\n          }), \"JsdocTypeTypeParameter\")\n        };\n      }\n      __name(identityTransformRules, \"identityTransformRules\");\n      const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: [\"parameters\", \"returnType\"],\n        JsdocTypeGeneric: [\"left\", \"elements\"],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: [\"right\"],\n        JsdocTypeIntersection: [\"elements\"],\n        JsdocTypeKeyof: [\"element\"],\n        JsdocTypeKeyValue: [\"right\"],\n        JsdocTypeMappedType: [\"right\"],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: [\"left\", \"right\"],\n        JsdocTypeNotNullable: [\"element\"],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: [\"element\"],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: [\"elements\"],\n        JsdocTypeObjectField: [\"right\"],\n        JsdocTypeJsdocObjectField: [\"left\", \"right\"],\n        JsdocTypeOptional: [\"element\"],\n        JsdocTypeParenthesis: [\"element\"],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: [\"element\"],\n        JsdocTypeTuple: [\"elements\"],\n        JsdocTypeTypeof: [\"element\"],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: [\"elements\"],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: [\"element\"],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: [\"left\", \"right\"],\n        JsdocTypeAsserts: [\"left\", \"right\"],\n        JsdocTypeReadonlyArray: [\"element\"],\n        JsdocTypeAssertsPlain: [\"element\"],\n        JsdocTypeConditional: [\"checksType\", \"extendsType\", \"trueType\", \"falseType\"],\n        JsdocTypeTypeParameter: [\"name\", \"constraint\", \"defaultValue\"]\n      };\n      function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n          const value = node[key];\n          if (value !== void 0) {\n            if (Array.isArray(value)) {\n              for (const element of value) {\n                _traverse(element, node, key, onEnter, onLeave);\n              }\n            } else {\n              _traverse(value, node, key, onEnter, onLeave);\n            }\n          }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n      }\n      __name(_traverse, \"_traverse\");\n      function traverse(node, onEnter, onLeave) {\n        _traverse(node, void 0, void 0, onEnter, onLeave);\n      }\n      __name(traverse, \"traverse\");\n      exports2.catharsisTransform = catharsisTransform;\n      exports2.identityTransformRules = identityTransformRules;\n      exports2.jtpTransform = jtpTransform;\n      exports2.parse = parse3;\n      exports2.stringify = stringify2;\n      exports2.stringifyRules = stringifyRules2;\n      exports2.transform = transform;\n      exports2.traverse = traverse;\n      exports2.tryParse = tryParse;\n      exports2.visitorKeys = visitorKeys;\n    });\n  }\n});\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError } from \"storybook/internal/preview-errors\";\nvar isLiteral = /* @__PURE__ */ __name((type) => type.name === \"literal\", \"isLiteral\");\nvar toEnumOption = /* @__PURE__ */ __name((element) => element.value.replace(/['|\"]/g, \"\"), \"toEnumOption\");\nvar convertSig = /* @__PURE__ */ __name((type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      const values = {};\n      type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert(prop.value);\n      });\n      return {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError({ type, language: \"Flow\" });\n  }\n}, \"convertSig\");\nvar convert = /* @__PURE__ */ __name((type) => {\n  const { name, raw } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (type.name) {\n    case \"literal\":\n      return { ...base, name: \"other\", value: type.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\": {\n      return { ...base, name };\n    }\n    case \"Array\": {\n      return { ...base, name: \"array\", value: type.elements.map(convert) };\n    }\n    case \"signature\":\n      return { ...base, ...convertSig(type) };\n    case \"union\":\n      if (type.elements?.every(isLiteral)) {\n        return { ...base, name: \"enum\", value: type.elements?.map(toEnumOption) };\n      }\n      return { ...base, name, value: type.elements?.map(convert) };\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar QUOTE_REGEX = /^['\"]|['\"]$/g;\nvar trimQuotes = /* @__PURE__ */ __name((str2) => str2.replace(QUOTE_REGEX, \"\"), \"trimQuotes\");\nvar includesQuotes = /* @__PURE__ */ __name((str2) => QUOTE_REGEX.test(str2), \"includesQuotes\");\nvar parseLiteral = /* @__PURE__ */ __name((str2) => {\n  const trimmedValue = trimQuotes(str2);\n  return includesQuotes(str2) || Number.isNaN(Number(trimmedValue)) ? trimmedValue : Number(trimmedValue);\n}, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar SIGNATURE_REGEXP = /^\\(.*\\) => /;\nvar convert2 = /* @__PURE__ */ __name((type) => {\n  const { name, raw, computed, value } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (name) {\n    case \"enum\": {\n      const values2 = computed ? value : value.map((v) => parseLiteral(v.value));\n      return { ...base, name, value: values2 };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...base, name };\n    case \"func\":\n      return { ...base, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...base, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...base, name: \"array\", value: value && convert2(value) };\n    case \"object\":\n      return { ...base, name };\n    case \"objectOf\":\n      return { ...base, name, value: convert2(value) };\n    case \"shape\":\n    case \"exact\":\n      const values = mapValues(value, (field) => convert2(field));\n      return { ...base, name: \"object\", value: values };\n    case \"union\":\n      return { ...base, name: \"union\", value: value.map((v) => convert2(v)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (name?.indexOf(\"|\") > 0) {\n        try {\n          const literalValues = name.split(\"|\").map((v) => JSON.parse(v));\n          return { ...base, name: \"enum\", value: literalValues };\n        } catch (err) {\n        }\n      }\n      const otherVal = value ? `${name}(${value})` : name;\n      const otherName = SIGNATURE_REGEXP.test(name) ? \"function\" : \"other\";\n      return { ...base, name: otherName, value: otherVal };\n    }\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as UnknownArgTypesError2 } from \"storybook/internal/preview-errors\";\nvar convertSig2 = /* @__PURE__ */ __name((type) => {\n  switch (type.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      const values = {};\n      type.signature.properties.forEach((prop) => {\n        values[prop.key] = convert3(prop.value);\n      });\n      return {\n        name: \"object\",\n        value: values\n      };\n    default:\n      throw new UnknownArgTypesError2({ type, language: \"Typescript\" });\n  }\n}, \"convertSig\");\nvar convert3 = /* @__PURE__ */ __name((type) => {\n  const { name, raw } = type;\n  const base = {};\n  if (typeof raw !== \"undefined\") {\n    base.raw = raw;\n  }\n  switch (type.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\": {\n      return { ...base, name };\n    }\n    case \"Array\": {\n      return { ...base, name: \"array\", value: type.elements.map(convert3) };\n    }\n    case \"signature\":\n      return { ...base, ...convertSig2(type) };\n    case \"union\":\n      let result;\n      if (type.elements?.every((element) => element.name === \"literal\")) {\n        result = {\n          ...base,\n          name: \"enum\",\n          // @ts-expect-error fix types\n          value: type.elements?.map((v) => parseLiteral(v.value))\n        };\n      } else {\n        result = { ...base, name, value: type.elements?.map(convert3) };\n      }\n      return result;\n    case \"intersection\":\n      return { ...base, name, value: type.elements?.map(convert3) };\n    default:\n      return { ...base, name: \"other\", value: name };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar convert4 = /* @__PURE__ */ __name((docgenInfo) => {\n  const { type, tsType, flowType } = docgenInfo;\n  try {\n    if (type != null) {\n      return convert2(type);\n    }\n    if (tsType != null) {\n      return convert3(tsType);\n    }\n    if (flowType != null) {\n      return convert(flowType);\n    }\n  } catch (err) {\n    console.error(err);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar TypeSystem = /* @__PURE__ */ ((TypeSystem2) => {\n  TypeSystem2[\"JAVASCRIPT\"] = \"JavaScript\";\n  TypeSystem2[\"FLOW\"] = \"Flow\";\n  TypeSystem2[\"TYPESCRIPT\"] = \"TypeScript\";\n  TypeSystem2[\"UNKNOWN\"] = \"Unknown\";\n  return TypeSystem2;\n})(TypeSystem || {});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar BLACKLIST = [\"null\", \"undefined\"];\nfunction isDefaultValueBlacklisted(value) {\n  return BLACKLIST.some((x) => x === value);\n}\n__name(isDefaultValueBlacklisted, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar str = /* @__PURE__ */ __name((obj) => {\n  if (!obj) {\n    return \"\";\n  }\n  if (typeof obj === \"string\") {\n    return obj;\n  }\n  throw new Error(`Description: expected string, got: ${JSON.stringify(obj)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction hasDocgen(component) {\n  return !!component.__docgenInfo;\n}\n__name(hasDocgen, \"hasDocgen\");\nfunction isValidDocgenSection(docgenSection) {\n  return docgenSection != null && Object.keys(docgenSection).length > 0;\n}\n__name(isValidDocgenSection, \"isValidDocgenSection\");\nfunction getDocgenSection(component, section) {\n  return hasDocgen(component) ? component.__docgenInfo[section] : null;\n}\n__name(getDocgenSection, \"getDocgenSection\");\nfunction getDocgenDescription(component) {\n  return hasDocgen(component) ? str(component.__docgenInfo.description) : \"\";\n}\n__name(getDocgenDescription, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar Markers;\n(function(Markers2) {\n  Markers2[\"start\"] = \"/**\";\n  Markers2[\"nostart\"] = \"/***\";\n  Markers2[\"delim\"] = \"*\";\n  Markers2[\"end\"] = \"*/\";\n})(Markers = Markers || (Markers = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction isSpace(source) {\n  return /^\\s+$/.test(source);\n}\n__name(isSpace, \"isSpace\");\nfunction splitCR(source) {\n  const matches = source.match(/\\r+$/);\n  return matches == null ? [\"\", source] : [source.slice(-matches[0].length), source.slice(0, -matches[0].length)];\n}\n__name(splitCR, \"splitCR\");\nfunction splitSpace(source) {\n  const matches = source.match(/^\\s+/);\n  return matches == null ? [\"\", source] : [source.slice(0, matches[0].length), source.slice(matches[0].length)];\n}\n__name(splitSpace, \"splitSpace\");\nfunction splitLines(source) {\n  return source.split(/\\n/);\n}\n__name(splitLines, \"splitLines\");\nfunction seedSpec(spec = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: false, description: \"\", problems: [], source: [] }, spec);\n}\n__name(seedSpec, \"seedSpec\");\nfunction seedTokens(tokens = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\", end: \"\", lineEnd: \"\" }, tokens);\n}\n__name(seedTokens, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar reTag = /^@\\S+/;\nfunction getParser({ fence = \"```\" } = {}) {\n  const fencer = getFencer(fence);\n  const toggleFence = /* @__PURE__ */ __name((source, isFenced) => fencer(source) ? !isFenced : isFenced, \"toggleFence\");\n  return /* @__PURE__ */ __name(function parseBlock(source) {\n    const sections = [[]];\n    let isFenced = false;\n    for (const line of source) {\n      if (reTag.test(line.tokens.description) && !isFenced) {\n        sections.push([line]);\n      } else {\n        sections[sections.length - 1].push(line);\n      }\n      isFenced = toggleFence(line.tokens.description, isFenced);\n    }\n    return sections;\n  }, \"parseBlock\");\n}\n__name(getParser, \"getParser\");\nfunction getFencer(fence) {\n  if (typeof fence === \"string\")\n    return (source) => source.split(fence).length % 2 === 0;\n  return fence;\n}\n__name(getFencer, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction getParser2({ startLine = 0, markers = Markers } = {}) {\n  let block = null;\n  let num = startLine;\n  return /* @__PURE__ */ __name(function parseSource(source) {\n    let rest = source;\n    const tokens = seedTokens();\n    [tokens.lineEnd, rest] = splitCR(rest);\n    [tokens.start, rest] = splitSpace(rest);\n    if (block === null && rest.startsWith(markers.start) && !rest.startsWith(markers.nostart)) {\n      block = [];\n      tokens.delimiter = rest.slice(0, markers.start.length);\n      rest = rest.slice(markers.start.length);\n      [tokens.postDelimiter, rest] = splitSpace(rest);\n    }\n    if (block === null) {\n      num++;\n      return null;\n    }\n    const isClosed = rest.trimRight().endsWith(markers.end);\n    if (tokens.delimiter === \"\" && rest.startsWith(markers.delim) && !rest.startsWith(markers.end)) {\n      tokens.delimiter = markers.delim;\n      rest = rest.slice(markers.delim.length);\n      [tokens.postDelimiter, rest] = splitSpace(rest);\n    }\n    if (isClosed) {\n      const trimmed = rest.trimRight();\n      tokens.end = rest.slice(trimmed.length - markers.end.length);\n      rest = trimmed.slice(0, -markers.end.length);\n    }\n    tokens.description = rest;\n    block.push({ number: num, source, tokens });\n    num++;\n    if (isClosed) {\n      const result = block.slice();\n      block = null;\n      return result;\n    }\n    return null;\n  }, \"parseSource\");\n}\n__name(getParser2, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction getParser3({ tokenizers }) {\n  return /* @__PURE__ */ __name(function parseSpec(source) {\n    var _a;\n    let spec = seedSpec({ source });\n    for (const tokenize of tokenizers) {\n      spec = tokenize(spec);\n      if ((_a = spec.problems[spec.problems.length - 1]) === null || _a === void 0 ? void 0 : _a.critical)\n        break;\n    }\n    return spec;\n  }, \"parseSpec\");\n}\n__name(getParser3, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction tagTokenizer() {\n  return (spec) => {\n    const { tokens } = spec.source[0];\n    const match = tokens.description.match(/\\s*(@(\\S+))(\\s*)/);\n    if (match === null) {\n      spec.problems.push({\n        code: \"spec:tag:prefix\",\n        message: 'tag should start with \"@\" symbol',\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    tokens.tag = match[1];\n    tokens.postTag = match[3];\n    tokens.description = tokens.description.slice(match[0].length);\n    spec.tag = match[2];\n    return spec;\n  };\n}\n__name(tagTokenizer, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction typeTokenizer(spacing = \"compact\") {\n  const join2 = getJoiner(spacing);\n  return (spec) => {\n    let curlies = 0;\n    let lines = [];\n    for (const [i, { tokens }] of spec.source.entries()) {\n      let type = \"\";\n      if (i === 0 && tokens.description[0] !== \"{\")\n        return spec;\n      for (const ch of tokens.description) {\n        if (ch === \"{\")\n          curlies++;\n        if (ch === \"}\")\n          curlies--;\n        type += ch;\n        if (curlies === 0)\n          break;\n      }\n      lines.push([tokens, type]);\n      if (curlies === 0)\n        break;\n    }\n    if (curlies !== 0) {\n      spec.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    const parts = [];\n    const offset = lines[0][0].postDelimiter.length;\n    for (const [i, [tokens, type]] of lines.entries()) {\n      tokens.type = type;\n      if (i > 0) {\n        tokens.type = tokens.postDelimiter.slice(offset) + type;\n        tokens.postDelimiter = tokens.postDelimiter.slice(0, offset);\n      }\n      [tokens.postType, tokens.description] = splitSpace(tokens.description.slice(type.length));\n      parts.push(tokens.type);\n    }\n    parts[0] = parts[0].slice(1);\n    parts[parts.length - 1] = parts[parts.length - 1].slice(0, -1);\n    spec.type = join2(parts);\n    return spec;\n  };\n}\n__name(typeTokenizer, \"typeTokenizer\");\nvar trim = /* @__PURE__ */ __name((x) => x.trim(), \"trim\");\nfunction getJoiner(spacing) {\n  if (spacing === \"compact\")\n    return (t) => t.map(trim).join(\"\");\n  else if (spacing === \"preserve\")\n    return (t) => t.join(\"\\n\");\n  else\n    return spacing;\n}\n__name(getJoiner, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar isQuoted = /* @__PURE__ */ __name((s) => s && s.startsWith('\"') && s.endsWith('\"'), \"isQuoted\");\nfunction nameTokenizer() {\n  const typeEnd = /* @__PURE__ */ __name((num, { tokens }, i) => tokens.type === \"\" ? num : i, \"typeEnd\");\n  return (spec) => {\n    const { tokens } = spec.source[spec.source.reduce(typeEnd, 0)];\n    const source = tokens.description.trimLeft();\n    const quotedGroups = source.split('\"');\n    if (quotedGroups.length > 1 && quotedGroups[0] === \"\" && quotedGroups.length % 2 === 1) {\n      spec.name = quotedGroups[1];\n      tokens.name = `\"${quotedGroups[1]}\"`;\n      [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));\n      return spec;\n    }\n    let brackets = 0;\n    let name = \"\";\n    let optional = false;\n    let defaultValue;\n    for (const ch of source) {\n      if (brackets === 0 && isSpace(ch))\n        break;\n      if (ch === \"[\")\n        brackets++;\n      if (ch === \"]\")\n        brackets--;\n      name += ch;\n    }\n    if (brackets !== 0) {\n      spec.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: spec.source[0].number,\n        critical: true\n      });\n      return spec;\n    }\n    const nameToken = name;\n    if (name[0] === \"[\" && name[name.length - 1] === \"]\") {\n      optional = true;\n      name = name.slice(1, -1);\n      const parts = name.split(\"=\");\n      name = parts[0].trim();\n      if (parts[1] !== void 0)\n        defaultValue = parts.slice(1).join(\"=\").trim();\n      if (name === \"\") {\n        spec.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n      if (defaultValue === \"\") {\n        spec.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n      if (!isQuoted(defaultValue) && /=(?!>)/.test(defaultValue)) {\n        spec.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: spec.source[0].number,\n          critical: true\n        });\n        return spec;\n      }\n    }\n    spec.optional = optional;\n    spec.name = name;\n    tokens.name = nameToken;\n    if (defaultValue !== void 0)\n      spec.default = defaultValue;\n    [tokens.postName, tokens.description] = splitSpace(source.slice(tokens.name.length));\n    return spec;\n  };\n}\n__name(nameTokenizer, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction descriptionTokenizer(spacing = \"compact\", markers = Markers) {\n  const join2 = getJoiner2(spacing);\n  return (spec) => {\n    spec.description = join2(spec.source, markers);\n    return spec;\n  };\n}\n__name(descriptionTokenizer, \"descriptionTokenizer\");\nfunction getJoiner2(spacing) {\n  if (spacing === \"compact\")\n    return compactJoiner;\n  if (spacing === \"preserve\")\n    return preserveJoiner;\n  return spacing;\n}\n__name(getJoiner2, \"getJoiner\");\nfunction compactJoiner(lines, markers = Markers) {\n  return lines.map(({ tokens: { description } }) => description.trim()).filter((description) => description !== \"\").join(\" \");\n}\n__name(compactJoiner, \"compactJoiner\");\nvar lineNo = /* @__PURE__ */ __name((num, { tokens }, i) => tokens.type === \"\" ? num : i, \"lineNo\");\nvar getDescription = /* @__PURE__ */ __name(({ tokens }) => (tokens.delimiter === \"\" ? tokens.start : tokens.postDelimiter.slice(1)) + tokens.description, \"getDescription\");\nfunction preserveJoiner(lines, markers = Markers) {\n  if (lines.length === 0)\n    return \"\";\n  if (lines[0].tokens.description === \"\" && lines[0].tokens.delimiter === markers.start)\n    lines = lines.slice(1);\n  const lastLine = lines[lines.length - 1];\n  if (lastLine !== void 0 && lastLine.tokens.description === \"\" && lastLine.tokens.end.endsWith(markers.end))\n    lines = lines.slice(0, -1);\n  lines = lines.slice(lines.reduce(lineNo, 0));\n  return lines.map(getDescription).join(\"\\n\");\n}\n__name(preserveJoiner, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction getParser4({ startLine = 0, fence = \"```\", spacing = \"compact\", markers = Markers, tokenizers = [\n  tagTokenizer(),\n  typeTokenizer(spacing),\n  nameTokenizer(),\n  descriptionTokenizer(spacing)\n] } = {}) {\n  if (startLine < 0 || startLine % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  const parseSource = getParser2({ startLine, markers });\n  const parseBlock = getParser({ fence });\n  const parseSpec = getParser3({ tokenizers });\n  const joinDescription = getJoiner2(spacing);\n  return function(source) {\n    const blocks = [];\n    for (const line of splitLines(source)) {\n      const lines = parseSource(line);\n      if (lines === null)\n        continue;\n      const sections = parseBlock(lines);\n      const specs = sections.slice(1).map(parseSpec);\n      blocks.push({\n        description: joinDescription(sections[0], markers),\n        tags: specs,\n        source: lines,\n        problems: specs.reduce((acc, spec) => acc.concat(spec.problems), [])\n      });\n    }\n    return blocks;\n  };\n}\n__name(getParser4, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction join(tokens) {\n  return tokens.start + tokens.delimiter + tokens.postDelimiter + tokens.tag + tokens.postTag + tokens.type + tokens.postType + tokens.name + tokens.postName + tokens.description + tokens.end + tokens.lineEnd;\n}\n__name(join, \"join\");\nfunction getStringifier() {\n  return (block) => block.source.map(({ tokens }) => join(tokens)).join(\"\\n\");\n}\n__name(getStringifier, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar zeroWidth = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar fields = Object.keys(zeroWidth);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction parse(source, options = {}) {\n  return getParser4(options)(source);\n}\n__name(parse, \"parse\");\nvar stringify = getStringifier();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nvar import_jsdoc_type_pratt_parser = __toESM(require_dist(), 1);\nfunction containsJsDoc(value) {\n  return value != null && value.includes(\"@\");\n}\n__name(containsJsDoc, \"containsJsDoc\");\nfunction parse2(content) {\n  const contentString = content ?? \"\";\n  const mappedLines = contentString.split(\"\\n\").map((line) => ` * ${line}`).join(\"\\n\");\n  const normalisedContent = \"/**\\n\" + mappedLines + \"\\n*/\";\n  const ast = parse(normalisedContent, {\n    spacing: \"preserve\"\n  });\n  if (!ast || ast.length === 0) {\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  }\n  return ast[0];\n}\n__name(parse2, \"parse\");\nvar DEFAULT_OPTIONS = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n};\nvar parseJsDoc = /* @__PURE__ */ __name((value, options = DEFAULT_OPTIONS) => {\n  if (!containsJsDoc(value)) {\n    return {\n      includesJsDoc: false,\n      ignore: false\n    };\n  }\n  const jsDocAst = parse2(value);\n  const extractedTags = extractJsDocTags(jsDocAst, options.tags);\n  if (extractedTags.ignore) {\n    return {\n      includesJsDoc: true,\n      ignore: true\n    };\n  }\n  return {\n    includesJsDoc: true,\n    ignore: false,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description.trim(),\n    extractedTags\n  };\n}, \"parseJsDoc\");\nfunction extractJsDocTags(ast, tags) {\n  const extractedTags = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: false\n  };\n  for (const tagSpec of ast.tags) {\n    if (tags !== void 0 && !tags.includes(tagSpec.tag)) {\n      continue;\n    }\n    if (tagSpec.tag === \"ignore\") {\n      extractedTags.ignore = true;\n      break;\n    } else {\n      switch (tagSpec.tag) {\n        // arg & argument are aliases for param.\n        case \"param\":\n        case \"arg\":\n        case \"argument\": {\n          const paramTag = extractParam(tagSpec);\n          if (paramTag != null) {\n            if (extractedTags.params == null) {\n              extractedTags.params = [];\n            }\n            extractedTags.params.push(paramTag);\n          }\n          break;\n        }\n        case \"deprecated\": {\n          const deprecatedTag = extractDeprecated(tagSpec);\n          if (deprecatedTag != null) {\n            extractedTags.deprecated = deprecatedTag;\n          }\n          break;\n        }\n        case \"returns\": {\n          const returnsTag = extractReturns(tagSpec);\n          if (returnsTag != null) {\n            extractedTags.returns = returnsTag;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  }\n  return extractedTags;\n}\n__name(extractJsDocTags, \"extractJsDocTags\");\nfunction normaliseParamName(name) {\n  return name.replace(/[\\.-]$/, \"\");\n}\n__name(normaliseParamName, \"normaliseParamName\");\nfunction extractParam(tag) {\n  if (!tag.name || tag.name === \"-\") {\n    return null;\n  }\n  const type = extractType(tag.type);\n  return {\n    name: tag.name,\n    type,\n    description: normaliseDescription(tag.description),\n    getPrettyName: /* @__PURE__ */ __name(() => {\n      return normaliseParamName(tag.name);\n    }, \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */ __name(() => {\n      return type ? extractTypeName(type) : null;\n    }, \"getTypeName\")\n  };\n}\n__name(extractParam, \"extractParam\");\nfunction extractDeprecated(tag) {\n  if (tag.name) {\n    return joinNameAndDescription(tag.name, tag.description);\n  }\n  return null;\n}\n__name(extractDeprecated, \"extractDeprecated\");\nfunction joinNameAndDescription(name, desc) {\n  const joined = name === \"\" ? desc : `${name} ${desc}`;\n  return normaliseDescription(joined);\n}\n__name(joinNameAndDescription, \"joinNameAndDescription\");\nfunction normaliseDescription(text) {\n  const normalised = text.replace(/^- /g, \"\").trim();\n  return normalised === \"\" ? null : normalised;\n}\n__name(normaliseDescription, \"normaliseDescription\");\nfunction extractReturns(tag) {\n  const type = extractType(tag.type);\n  if (type) {\n    return {\n      type,\n      description: joinNameAndDescription(tag.name, tag.description),\n      getTypeName: /* @__PURE__ */ __name(() => {\n        return extractTypeName(type);\n      }, \"getTypeName\")\n    };\n  }\n  return null;\n}\n__name(extractReturns, \"extractReturns\");\nvar jsdocStringifyRules = (0, import_jsdoc_type_pratt_parser.stringifyRules)();\nvar originalJsdocStringifyObject = jsdocStringifyRules.JsdocTypeObject;\njsdocStringifyRules.JsdocTypeAny = () => \"any\";\njsdocStringifyRules.JsdocTypeObject = (result, transform) => `(${originalJsdocStringifyObject(result, transform)})`;\njsdocStringifyRules.JsdocTypeOptional = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeNotNullable = (result, transform) => transform(result.element);\njsdocStringifyRules.JsdocTypeUnion = (result, transform) => result.elements.map(transform).join(\"|\");\nfunction extractType(typeString) {\n  try {\n    return (0, import_jsdoc_type_pratt_parser.parse)(typeString, \"typescript\");\n  } catch (_err) {\n    return null;\n  }\n}\n__name(extractType, \"extractType\");\nfunction extractTypeName(type) {\n  return (0, import_jsdoc_type_pratt_parser.transform)(jsdocStringifyRules, type);\n}\n__name(extractTypeName, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar MAX_TYPE_SUMMARY_LENGTH = 90;\nvar MAX_DEFAULT_VALUE_SUMMARY_LENGTH = 50;\nfunction isTooLongForTypeSummary(value) {\n  return value.length > MAX_TYPE_SUMMARY_LENGTH;\n}\n__name(isTooLongForTypeSummary, \"isTooLongForTypeSummary\");\nfunction isTooLongForDefaultValueSummary(value) {\n  return value.length > MAX_DEFAULT_VALUE_SUMMARY_LENGTH;\n}\n__name(isTooLongForDefaultValueSummary, \"isTooLongForDefaultValueSummary\");\nfunction createSummaryValue(summary, detail) {\n  if (summary === detail) {\n    return { summary };\n  }\n  return { summary, detail };\n}\n__name(createSummaryValue, \"createSummaryValue\");\nvar normalizeNewlines = /* @__PURE__ */ __name((string) => string.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction createDefaultValue(defaultValue, type) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      return !isTooLongForDefaultValueSummary(value) ? createSummaryValue(value) : createSummaryValue(type?.name, value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction generateUnionElement({ name, value, elements, raw }) {\n  if (value != null) {\n    return value;\n  }\n  if (elements != null) {\n    return elements.map(generateUnionElement).join(\" | \");\n  }\n  if (raw != null) {\n    return raw;\n  }\n  return name;\n}\n__name(generateUnionElement, \"generateUnionElement\");\nfunction generateUnion({ name, raw, elements }) {\n  if (elements != null) {\n    return createSummaryValue(elements.map(generateUnionElement).join(\" | \"));\n  }\n  if (raw != null) {\n    return createSummaryValue(raw.replace(/^\\|\\s*/, \"\"));\n  }\n  return createSummaryValue(name);\n}\n__name(generateUnion, \"generateUnion\");\nfunction generateFuncSignature({ type, raw }) {\n  if (raw != null) {\n    return createSummaryValue(raw);\n  }\n  return createSummaryValue(type);\n}\n__name(generateFuncSignature, \"generateFuncSignature\");\nfunction generateObjectSignature({ type, raw }) {\n  if (raw != null) {\n    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(type, raw);\n  }\n  return createSummaryValue(type);\n}\n__name(generateObjectSignature, \"generateObjectSignature\");\nfunction generateSignature(flowType) {\n  const { type } = flowType;\n  return type === \"object\" ? generateObjectSignature(flowType) : generateFuncSignature(flowType);\n}\n__name(generateSignature, \"generateSignature\");\nfunction generateDefault({ name, raw }) {\n  if (raw != null) {\n    return !isTooLongForTypeSummary(raw) ? createSummaryValue(raw) : createSummaryValue(name, raw);\n  }\n  return createSummaryValue(name);\n}\n__name(generateDefault, \"generateDefault\");\nfunction createType(type) {\n  if (type == null) {\n    return null;\n  }\n  switch (type.name) {\n    case \"union\" /* UNION */:\n      return generateUnion(type);\n    case \"signature\" /* SIGNATURE */:\n      return generateSignature(type);\n    default:\n      return generateDefault(type);\n  }\n}\n__name(createType, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar createFlowPropDef = /* @__PURE__ */ __name((propName, docgenInfo) => {\n  const { flowType, description, required, defaultValue } = docgenInfo;\n  return {\n    name: propName,\n    type: createType(flowType),\n    required,\n    description,\n    defaultValue: createDefaultValue(defaultValue ?? null, flowType ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction createDefaultValue2({ defaultValue }) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      return createSummaryValue(value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue2, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction createType2({ tsType, required }) {\n  if (tsType == null) {\n    return null;\n  }\n  let typeName = tsType.name;\n  if (!required) {\n    typeName = typeName.replace(\" | undefined\", \"\");\n  }\n  return createSummaryValue(\n    [\"Array\", \"Record\", \"signature\"].includes(tsType.name) ? tsType.raw : typeName\n  );\n}\n__name(createType2, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar createTsPropDef = /* @__PURE__ */ __name((propName, docgenInfo) => {\n  const { description, required } = docgenInfo;\n  return {\n    name: propName,\n    type: createType2(docgenInfo),\n    required,\n    description,\n    defaultValue: createDefaultValue2(docgenInfo)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction createType3(type) {\n  return type != null ? createSummaryValue(type.name) : null;\n}\n__name(createType3, \"createType\");\nfunction isReactDocgenTypescript(defaultValue) {\n  const { computed, func } = defaultValue;\n  return typeof computed === \"undefined\" && typeof func === \"undefined\";\n}\n__name(isReactDocgenTypescript, \"isReactDocgenTypescript\");\nfunction isStringValued(type) {\n  if (!type) {\n    return false;\n  }\n  if (type.name === \"string\") {\n    return true;\n  }\n  if (type.name === \"enum\") {\n    return Array.isArray(type.value) && type.value.every(\n      ({ value: tv }) => typeof tv === \"string\" && tv[0] === '\"' && tv[tv.length - 1] === '\"'\n    );\n  }\n  return false;\n}\n__name(isStringValued, \"isStringValued\");\nfunction createDefaultValue3(defaultValue, type) {\n  if (defaultValue != null) {\n    const { value } = defaultValue;\n    if (!isDefaultValueBlacklisted(value)) {\n      if (isReactDocgenTypescript(defaultValue) && isStringValued(type)) {\n        return createSummaryValue(JSON.stringify(value));\n      }\n      return createSummaryValue(value);\n    }\n  }\n  return null;\n}\n__name(createDefaultValue3, \"createDefaultValue\");\nfunction createBasicPropDef(name, type, docgenInfo) {\n  const { description, required, defaultValue } = docgenInfo;\n  return {\n    name,\n    type: createType3(type),\n    required,\n    description,\n    defaultValue: createDefaultValue3(defaultValue, type)\n  };\n}\n__name(createBasicPropDef, \"createBasicPropDef\");\nfunction applyJsDocResult(propDef, jsDocParsingResult) {\n  if (jsDocParsingResult?.includesJsDoc) {\n    const { description, extractedTags } = jsDocParsingResult;\n    if (description != null) {\n      propDef.description = jsDocParsingResult.description;\n    }\n    const value = {\n      ...extractedTags,\n      params: extractedTags?.params?.map(\n        (x) => ({\n          name: x.getPrettyName(),\n          description: x.description\n        })\n      )\n    };\n    if (Object.values(value).filter(Boolean).length > 0) {\n      propDef.jsDocTags = value;\n    }\n  }\n  return propDef;\n}\n__name(applyJsDocResult, \"applyJsDocResult\");\nvar javaScriptFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createBasicPropDef(propName, docgenInfo.type, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"javaScriptFactory\");\nvar tsFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createTsPropDef(propName, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"tsFactory\");\nvar flowFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createFlowPropDef(propName, docgenInfo);\n  propDef.sbType = convert4(docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"flowFactory\");\nvar unknownFactory = /* @__PURE__ */ __name((propName, docgenInfo, jsDocParsingResult) => {\n  const propDef = createBasicPropDef(propName, { name: \"unknown\" }, docgenInfo);\n  return applyJsDocResult(propDef, jsDocParsingResult);\n}, \"unknownFactory\");\nvar getPropDefFactory = /* @__PURE__ */ __name((typeSystem) => {\n  switch (typeSystem) {\n    case \"JavaScript\" /* JAVASCRIPT */:\n      return javaScriptFactory;\n    case \"TypeScript\" /* TYPESCRIPT */:\n      return tsFactory;\n    case \"Flow\" /* FLOW */:\n      return flowFactory;\n    default:\n      return unknownFactory;\n  }\n}, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar getTypeSystem = /* @__PURE__ */ __name((docgenInfo) => {\n  if (docgenInfo.type != null) {\n    return \"JavaScript\" /* JAVASCRIPT */;\n  }\n  if (docgenInfo.flowType != null) {\n    return \"Flow\" /* FLOW */;\n  }\n  if (docgenInfo.tsType != null) {\n    return \"TypeScript\" /* TYPESCRIPT */;\n  }\n  return \"Unknown\" /* UNKNOWN */;\n}, \"getTypeSystem\");\nvar extractComponentSectionArray = /* @__PURE__ */ __name((docgenSection) => {\n  const typeSystem = getTypeSystem(docgenSection[0]);\n  const createPropDef = getPropDefFactory(typeSystem);\n  return docgenSection.map((item) => {\n    let sanitizedItem = item;\n    if (item.type?.elements) {\n      sanitizedItem = {\n        ...item,\n        type: {\n          ...item.type,\n          value: item.type.elements\n        }\n      };\n    }\n    return extractProp(sanitizedItem.name, sanitizedItem, typeSystem, createPropDef);\n  });\n}, \"extractComponentSectionArray\");\nvar extractComponentSectionObject = /* @__PURE__ */ __name((docgenSection) => {\n  const docgenPropsKeys = Object.keys(docgenSection);\n  const typeSystem = getTypeSystem(docgenSection[docgenPropsKeys[0]]);\n  const createPropDef = getPropDefFactory(typeSystem);\n  return docgenPropsKeys.map((propName) => {\n    const docgenInfo = docgenSection[propName];\n    return docgenInfo != null ? extractProp(propName, docgenInfo, typeSystem, createPropDef) : null;\n  }).filter(Boolean);\n}, \"extractComponentSectionObject\");\nvar extractComponentProps = /* @__PURE__ */ __name((component, section) => {\n  const docgenSection = getDocgenSection(component, section);\n  if (!isValidDocgenSection(docgenSection)) {\n    return [];\n  }\n  return Array.isArray(docgenSection) ? extractComponentSectionArray(docgenSection) : extractComponentSectionObject(docgenSection);\n}, \"extractComponentProps\");\nfunction extractProp(propName, docgenInfo, typeSystem, createPropDef) {\n  const jsDocParsingResult = parseJsDoc(docgenInfo.description);\n  const isIgnored = jsDocParsingResult.includesJsDoc && jsDocParsingResult.ignore;\n  if (!isIgnored) {\n    const propDef = createPropDef(propName, docgenInfo, jsDocParsingResult);\n    return {\n      propDef,\n      jsDocTags: jsDocParsingResult.extractedTags,\n      docgenInfo,\n      typeSystem\n    };\n  }\n  return null;\n}\n__name(extractProp, \"extractProp\");\nfunction extractComponentDescription(component) {\n  return component != null ? getDocgenDescription(component) : \"\";\n}\n__name(extractComponentDescription, \"extractComponentDescription\");\n\n// src/preview-api/modules/store/parameters.ts\nvar combineParameters = /* @__PURE__ */ __name((...parameterSets) => {\n  const mergeKeys = {};\n  const definedParametersSets = parameterSets.filter(Boolean);\n  const combined = definedParametersSets.reduce((acc, parameters) => {\n    Object.entries(parameters).forEach(([key, value]) => {\n      const existing = acc[key];\n      if (Array.isArray(value) || typeof existing === \"undefined\") {\n        acc[key] = value;\n      } else if (isPlainObject(value) && isPlainObject(existing)) {\n        mergeKeys[key] = true;\n      } else if (typeof value !== \"undefined\") {\n        acc[key] = value;\n      }\n    });\n    return acc;\n  }, {});\n  Object.keys(mergeKeys).forEach((key) => {\n    const mergeValues = definedParametersSets.filter(Boolean).map((p) => p[key]).filter((value) => typeof value !== \"undefined\");\n    if (mergeValues.every((value) => isPlainObject(value))) {\n      combined[key] = combineParameters(...mergeValues);\n    } else {\n      combined[key] = mergeValues[mergeValues.length - 1];\n    }\n  });\n  return combined;\n}, \"combineParameters\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nvar enhanceArgTypes = /* @__PURE__ */ __name((context) => {\n  const {\n    component,\n    argTypes: userArgTypes,\n    parameters: { docs = {} }\n  } = context;\n  const { extractArgTypes } = docs;\n  if (!extractArgTypes || !component) {\n    return userArgTypes;\n  }\n  const extractedArgTypes = extractArgTypes(component);\n  return extractedArgTypes ? combineParameters(extractedArgTypes, userArgTypes) : userArgTypes;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar ADDON_ID = \"storybook/docs\";\nvar PANEL_ID = `${ADDON_ID}/panel`;\nvar PARAM_KEY = `docs`;\nvar SNIPPET_RENDERED = `${ADDON_ID}/snippet-rendered`;\nvar SourceType = /* @__PURE__ */ ((SourceType2) => {\n  SourceType2[\"AUTO\"] = \"auto\";\n  SourceType2[\"CODE\"] = \"code\";\n  SourceType2[\"DYNAMIC\"] = \"dynamic\";\n  return SourceType2;\n})(SourceType || {});\n\nexport {\n  combineParameters,\n  convert4 as convert,\n  TypeSystem,\n  isDefaultValueBlacklisted,\n  str,\n  hasDocgen,\n  isValidDocgenSection,\n  getDocgenSection,\n  getDocgenDescription,\n  parseJsDoc,\n  MAX_TYPE_SUMMARY_LENGTH,\n  MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  isTooLongForTypeSummary,\n  isTooLongForDefaultValueSummary,\n  createSummaryValue,\n  normalizeNewlines,\n  extractComponentSectionArray,\n  extractComponentSectionObject,\n  extractComponentProps,\n  extractComponentDescription,\n  enhanceArgTypes,\n  ADDON_ID,\n  PANEL_ID,\n  PARAM_KEY,\n  SNIPPET_RENDERED,\n  SourceType\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}