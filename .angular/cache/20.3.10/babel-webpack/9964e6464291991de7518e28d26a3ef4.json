{"ast":null,"code":"import { CallStates, EVENTS } from \"../_browser-chunks/chunk-SN4J4IQ3.js\";\nimport { processError } from \"../_browser-chunks/chunk-JVSKG4YS.js\";\nimport { __name } from \"../_browser-chunks/chunk-MM7DTO55.js\";\n\n// src/instrumenter/instrumenter.ts\nimport { once } from \"storybook/internal/client-logger\";\nimport { FORCE_REMOUNT, SET_CURRENT_STORY, STORY_RENDER_PHASE_CHANGED } from \"storybook/internal/core-events\";\nimport { global } from \"@storybook/global\";\n\n// src/instrumenter/preview-api.ts\nvar addons = globalThis.__STORYBOOK_ADDONS_PREVIEW;\n\n// src/instrumenter/instrumenter.ts\nvar alreadyCompletedException = new Error(`This function ran after the play function completed. Did you forget to \\`await\\` it?`);\nvar isObject = /* @__PURE__ */__name(o => Object.prototype.toString.call(o) === \"[object Object]\", \"isObject\");\nvar isModule = /* @__PURE__ */__name(o => Object.prototype.toString.call(o) === \"[object Module]\", \"isModule\");\nvar isInstrumentable = /* @__PURE__ */__name(o => {\n  if (!isObject(o) && !isModule(o)) {\n    return false;\n  }\n  if (o.constructor === void 0) {\n    return true;\n  }\n  const proto = o.constructor.prototype;\n  if (!isObject(proto)) {\n    return false;\n  }\n  return true;\n}, \"isInstrumentable\");\nvar construct = /* @__PURE__ */__name(obj => {\n  try {\n    return new obj.constructor();\n  } catch {\n    return {};\n  }\n}, \"construct\");\nvar getInitialState = /* @__PURE__ */__name(() => ({\n  renderPhase: \"preparing\",\n  isDebugging: false,\n  isPlaying: false,\n  isLocked: false,\n  cursor: 0,\n  calls: [],\n  shadowCalls: [],\n  callRefsByResult: /* @__PURE__ */new Map(),\n  chainedCallIds: /* @__PURE__ */new Set(),\n  ancestors: [],\n  playUntil: void 0,\n  resolvers: {},\n  syncTimeout: void 0\n}), \"getInitialState\");\nvar getRetainedState = /* @__PURE__ */__name((state, isDebugging = false) => {\n  const calls = (isDebugging ? state.shadowCalls : state.calls).filter(call => call.retain);\n  if (!calls.length) {\n    return void 0;\n  }\n  const callRefsByResult = new Map(Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain));\n  return {\n    cursor: calls.length,\n    calls,\n    callRefsByResult\n  };\n}, \"getRetainedState\");\nvar _Instrumenter = class _Instrumenter {\n  constructor() {\n    this.detached = false;\n    this.initialized = false;\n    // State is tracked per story to deal with multiple stories on the same canvas (i.e. docs mode)\n    this.state = {};\n    this.loadParentWindowState = /* @__PURE__ */__name(() => {\n      try {\n        this.state = global.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};\n      } catch {\n        this.detached = true;\n      }\n    }, \"loadParentWindowState\");\n    this.updateParentWindowState = /* @__PURE__ */__name(() => {\n      try {\n        global.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n      } catch {\n        this.detached = true;\n      }\n    }, \"updateParentWindowState\");\n    this.loadParentWindowState();\n    const resetState = /* @__PURE__ */__name(({\n      storyId,\n      renderPhase,\n      isPlaying = true,\n      isDebugging = false\n    }) => {\n      const state = this.getState(storyId);\n      this.setState(storyId, {\n        ...getInitialState(),\n        ...getRetainedState(state, isDebugging),\n        renderPhase: renderPhase || state.renderPhase,\n        shadowCalls: isDebugging ? state.shadowCalls : [],\n        chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */new Set(),\n        playUntil: isDebugging ? state.playUntil : void 0,\n        isPlaying,\n        isDebugging\n      });\n      this.sync(storyId);\n    }, \"resetState\");\n    const start = /* @__PURE__ */__name(channel => ({\n      storyId,\n      playUntil\n    }) => {\n      if (!this.getState(storyId).isDebugging) {\n        this.setState(storyId, ({\n          calls\n        }) => ({\n          calls: [],\n          shadowCalls: calls.map(call => ({\n            ...call,\n            status: \"waiting\" /* WAITING */\n          })),\n          isDebugging: true\n        }));\n      }\n      const log = this.getLog(storyId);\n      this.setState(storyId, ({\n        shadowCalls\n      }) => {\n        if (playUntil || !log.length) {\n          return {\n            playUntil\n          };\n        }\n        const firstRowIndex = shadowCalls.findIndex(call => call.id === log[0].callId);\n        return {\n          playUntil: shadowCalls.slice(0, firstRowIndex).filter(call => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id\n        };\n      });\n      channel.emit(FORCE_REMOUNT, {\n        storyId,\n        isDebugging: true\n      });\n    }, \"start\");\n    const back = /* @__PURE__ */__name(channel => ({\n      storyId\n    }) => {\n      const log = this.getLog(storyId).filter(call => !call.ancestors?.length);\n      const last = log.reduceRight((res, item, index) => {\n        if (res >= 0 || item.status === \"waiting\" /* WAITING */) {\n          return res;\n        }\n        return index;\n      }, -1);\n      start(channel)({\n        storyId,\n        playUntil: log[last - 1]?.callId\n      });\n    }, \"back\");\n    const goto = /* @__PURE__ */__name(channel => ({\n      storyId,\n      callId\n    }) => {\n      const {\n        calls,\n        shadowCalls,\n        resolvers\n      } = this.getState(storyId);\n      const call = calls.find(({\n        id\n      }) => id === callId);\n      const shadowCall = shadowCalls.find(({\n        id\n      }) => id === callId);\n      if (!call && shadowCall && Object.values(resolvers).length > 0) {\n        const nextId = this.getLog(storyId).find(c => c.status === \"waiting\" /* WAITING */)?.callId;\n        if (shadowCall.id !== nextId) {\n          this.setState(storyId, {\n            playUntil: shadowCall.id\n          });\n        }\n        Object.values(resolvers).forEach(resolve => resolve());\n      } else {\n        start(channel)({\n          storyId,\n          playUntil: callId\n        });\n      }\n    }, \"goto\");\n    const next = /* @__PURE__ */__name(channel => ({\n      storyId\n    }) => {\n      const {\n        resolvers\n      } = this.getState(storyId);\n      if (Object.values(resolvers).length > 0) {\n        Object.values(resolvers).forEach(resolve => resolve());\n      } else {\n        const nextId = this.getLog(storyId).find(c => c.status === \"waiting\" /* WAITING */)?.callId;\n        if (nextId) {\n          start(channel)({\n            storyId,\n            playUntil: nextId\n          });\n        } else {\n          end({\n            storyId\n          });\n        }\n      }\n    }, \"next\");\n    const end = /* @__PURE__ */__name(({\n      storyId\n    }) => {\n      this.setState(storyId, {\n        playUntil: void 0,\n        isDebugging: false\n      });\n      Object.values(this.getState(storyId).resolvers).forEach(resolve => resolve());\n    }, \"end\");\n    const renderPhaseChanged = /* @__PURE__ */__name(({\n      storyId,\n      newPhase\n    }) => {\n      const {\n        isDebugging\n      } = this.getState(storyId);\n      if (newPhase === \"preparing\" && isDebugging) {\n        return resetState({\n          storyId,\n          renderPhase: newPhase,\n          isDebugging\n        });\n      } else if (newPhase === \"playing\") {\n        return resetState({\n          storyId,\n          renderPhase: newPhase,\n          isDebugging\n        });\n      }\n      if (newPhase === \"played\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: false,\n          isPlaying: false,\n          isDebugging: false\n        });\n      } else if (newPhase === \"errored\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: false,\n          isPlaying: false\n        });\n      } else if (newPhase === \"aborted\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: true,\n          isPlaying: false\n        });\n      } else {\n        this.setState(storyId, {\n          renderPhase: newPhase\n        });\n      }\n      this.sync(storyId);\n    }, \"renderPhaseChanged\");\n    if (addons) {\n      addons.ready().then(() => {\n        this.channel = addons.getChannel();\n        this.channel.on(FORCE_REMOUNT, resetState);\n        this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged);\n        this.channel.on(SET_CURRENT_STORY, () => {\n          if (this.initialized) {\n            this.cleanup();\n          } else {\n            this.initialized = true;\n          }\n        });\n        this.channel.on(EVENTS.START, start(this.channel));\n        this.channel.on(EVENTS.BACK, back(this.channel));\n        this.channel.on(EVENTS.GOTO, goto(this.channel));\n        this.channel.on(EVENTS.NEXT, next(this.channel));\n        this.channel.on(EVENTS.END, end);\n      });\n    }\n  }\n  getState(storyId) {\n    return this.state[storyId] || getInitialState();\n  }\n  setState(storyId, update) {\n    if (storyId) {\n      const state = this.getState(storyId);\n      const patch = typeof update === \"function\" ? update(state) : update;\n      this.state = {\n        ...this.state,\n        [storyId]: {\n          ...state,\n          ...patch\n        }\n      };\n      this.updateParentWindowState();\n    }\n  }\n  cleanup() {\n    this.state = Object.entries(this.state).reduce((acc, [storyId, state]) => {\n      const retainedState = getRetainedState(state);\n      if (!retainedState) {\n        return acc;\n      }\n      acc[storyId] = Object.assign(getInitialState(), retainedState);\n      return acc;\n    }, {});\n    const controlStates = {\n      detached: this.detached,\n      start: false,\n      back: false,\n      goto: false,\n      next: false,\n      end: false\n    };\n    const payload = {\n      controlStates,\n      logItems: []\n    };\n    this.channel?.emit(EVENTS.SYNC, payload);\n    this.updateParentWindowState();\n  }\n  getLog(storyId) {\n    const {\n      calls,\n      shadowCalls\n    } = this.getState(storyId);\n    const merged = [...shadowCalls];\n    calls.forEach((call, index) => {\n      merged[index] = call;\n    });\n    const seen = /* @__PURE__ */new Set();\n    return merged.reduceRight((acc, call) => {\n      call.args.forEach(arg => {\n        if (arg?.__callId__) {\n          seen.add(arg.__callId__);\n        }\n      });\n      call.path.forEach(node => {\n        if (node.__callId__) {\n          seen.add(node.__callId__);\n        }\n      });\n      if ((call.interceptable || call.exception) && !seen.has(call.id)) {\n        acc.unshift({\n          callId: call.id,\n          status: call.status,\n          ancestors: call.ancestors\n        });\n        seen.add(call.id);\n      }\n      return acc;\n    }, []);\n  }\n  // Traverses the object structure to recursively patch all function properties.\n  // Returns the original object, or a new object with the same constructor,\n  // depending on whether it should mutate.\n  instrument(obj, options, depth = 0) {\n    if (!isInstrumentable(obj)) {\n      return obj;\n    }\n    const {\n      mutate = false,\n      path = []\n    } = options;\n    const keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);\n    depth += 1;\n    return keys.reduce((acc, key) => {\n      const descriptor = getPropertyDescriptor(obj, key);\n      if (typeof descriptor?.get === \"function\") {\n        if (descriptor.configurable) {\n          const getter = /* @__PURE__ */__name(() => descriptor?.get?.bind(obj)?.(), \"getter\");\n          Object.defineProperty(acc, key, {\n            get: /* @__PURE__ */__name(() => {\n              return this.instrument(getter(), {\n                ...options,\n                path: path.concat(key)\n              }, depth);\n            }, \"get\")\n          });\n        }\n        return acc;\n      }\n      const value = obj[key];\n      if (typeof value !== \"function\") {\n        acc[key] = this.instrument(value, {\n          ...options,\n          path: path.concat(key)\n        }, depth);\n        return acc;\n      }\n      if (\"__originalFn__\" in value && typeof value.__originalFn__ === \"function\") {\n        acc[key] = value;\n        return acc;\n      }\n      acc[key] = (...args) => this.track(key, value, obj, args, options);\n      acc[key].__originalFn__ = value;\n      Object.defineProperty(acc[key], \"name\", {\n        value: key,\n        writable: false\n      });\n      if (Object.keys(value).length > 0) {\n        Object.assign(acc[key], this.instrument({\n          ...value\n        }, {\n          ...options,\n          path: path.concat(key)\n        }, depth));\n      }\n      return acc;\n    }, mutate ? obj : construct(obj));\n  }\n  // Monkey patch an object method to record calls.\n  // Returns a function that invokes the original function, records the invocation (\"call\") and\n  // returns the original result.\n  track(method, fn, object, args, options) {\n    const storyId = args?.[0]?.__storyId__ || global.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId;\n    const {\n      cursor,\n      ancestors\n    } = this.getState(storyId);\n    this.setState(storyId, {\n      cursor: cursor + 1\n    });\n    const id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`;\n    const {\n      path = [],\n      intercept = false,\n      retain = false\n    } = options;\n    const interceptable = typeof intercept === \"function\" ? intercept(method, path) : intercept;\n    const call = {\n      id,\n      cursor,\n      storyId,\n      ancestors,\n      path,\n      method,\n      args,\n      interceptable,\n      retain\n    };\n    const interceptOrInvoke = interceptable && !ancestors.length ? this.intercept : this.invoke;\n    const result = interceptOrInvoke.call(this, fn, object, call, options);\n    return this.instrument(result, {\n      ...options,\n      mutate: true,\n      path: [{\n        __callId__: call.id\n      }]\n    });\n  }\n  intercept(fn, object, call, options) {\n    const {\n      chainedCallIds,\n      isDebugging,\n      playUntil\n    } = this.getState(call.storyId);\n    const isChainedUpon = chainedCallIds.has(call.id);\n    if (!isDebugging || isChainedUpon || playUntil) {\n      if (playUntil === call.id) {\n        this.setState(call.storyId, {\n          playUntil: void 0\n        });\n      }\n      return this.invoke(fn, object, call, options);\n    }\n    return new Promise(resolve => {\n      this.setState(call.storyId, ({\n        resolvers\n      }) => ({\n        isLocked: false,\n        resolvers: {\n          ...resolvers,\n          [call.id]: resolve\n        }\n      }));\n    }).then(() => {\n      this.setState(call.storyId, state => {\n        const {\n          [call.id]: _,\n          ...resolvers\n        } = state.resolvers;\n        return {\n          isLocked: true,\n          resolvers\n        };\n      });\n      return this.invoke(fn, object, call, options);\n    });\n  }\n  invoke(fn, object, call, options) {\n    const {\n      callRefsByResult,\n      renderPhase\n    } = this.getState(call.storyId);\n    const maximumDepth = 25;\n    const serializeValues = /* @__PURE__ */__name((value, depth, seen) => {\n      if (seen.includes(value)) {\n        return \"[Circular]\";\n      }\n      seen = [...seen, value];\n      if (depth > maximumDepth) {\n        return \"...\";\n      }\n      if (callRefsByResult.has(value)) {\n        return callRefsByResult.get(value);\n      }\n      if (value instanceof Array) {\n        return value.map(it => serializeValues(it, ++depth, seen));\n      }\n      if (value instanceof Date) {\n        return {\n          __date__: {\n            value: value.toISOString()\n          }\n        };\n      }\n      if (value instanceof Error) {\n        const {\n          name,\n          message,\n          stack\n        } = value;\n        return {\n          __error__: {\n            name,\n            message,\n            stack\n          }\n        };\n      }\n      if (value instanceof RegExp) {\n        const {\n          flags,\n          source\n        } = value;\n        return {\n          __regexp__: {\n            flags,\n            source\n          }\n        };\n      }\n      if (value instanceof global.window?.HTMLElement) {\n        const {\n          prefix,\n          localName,\n          id,\n          classList,\n          innerText\n        } = value;\n        const classNames = Array.from(classList);\n        return {\n          __element__: {\n            prefix,\n            localName,\n            id,\n            classNames,\n            innerText\n          }\n        };\n      }\n      if (typeof value === \"function\") {\n        return {\n          __function__: {\n            name: \"getMockName\" in value ? value.getMockName() : value.name\n          }\n        };\n      }\n      if (typeof value === \"symbol\") {\n        return {\n          __symbol__: {\n            description: value.description\n          }\n        };\n      }\n      if (typeof value === \"object\" && value?.constructor?.name && value?.constructor?.name !== \"Object\") {\n        return {\n          __class__: {\n            name: value.constructor.name\n          }\n        };\n      }\n      if (Object.prototype.toString.call(value) === \"[object Object]\") {\n        return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)]));\n      }\n      return value;\n    }, \"serializeValues\");\n    const info = {\n      ...call,\n      args: call.args.map(arg => serializeValues(arg, 0, []))\n    };\n    call.path.forEach(ref => {\n      if (ref?.__callId__) {\n        this.setState(call.storyId, ({\n          chainedCallIds\n        }) => ({\n          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))\n        }));\n      }\n    });\n    const handleException = /* @__PURE__ */__name(e => {\n      if (e instanceof Error) {\n        const {\n          name,\n          message,\n          stack,\n          callId = call.id\n        } = e;\n        const {\n          showDiff = void 0,\n          diff = void 0,\n          actual = void 0,\n          expected = void 0\n        } = e.name === \"AssertionError\" ? processError(e) : e;\n        const exception = {\n          name,\n          message,\n          stack,\n          callId,\n          showDiff,\n          diff,\n          actual,\n          expected\n        };\n        this.update({\n          ...info,\n          status: \"error\" /* ERROR */,\n          exception\n        });\n        this.setState(call.storyId, state => ({\n          callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [e, {\n            __callId__: call.id,\n            retain: call.retain\n          }]])\n        }));\n        if (call.ancestors?.length) {\n          if (!Object.prototype.hasOwnProperty.call(e, \"callId\")) {\n            Object.defineProperty(e, \"callId\", {\n              value: call.id\n            });\n          }\n          throw e;\n        }\n      }\n      throw e;\n    }, \"handleException\");\n    try {\n      if (renderPhase === \"played\" && !call.retain) {\n        throw alreadyCompletedException;\n      }\n      const actualArgs = options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args;\n      const finalArgs = actualArgs.map(arg => {\n        if (typeof arg !== \"function\" || isClass(arg) || Object.keys(arg).length) {\n          return arg;\n        }\n        return (...args) => {\n          const {\n            cursor,\n            ancestors\n          } = this.getState(call.storyId);\n          this.setState(call.storyId, {\n            cursor: 0,\n            ancestors: [...ancestors, call.id]\n          });\n          const restore = /* @__PURE__ */__name(() => this.setState(call.storyId, {\n            cursor,\n            ancestors\n          }), \"restore\");\n          let willRestore = false;\n          try {\n            const res = arg(...args);\n            if (res instanceof Promise) {\n              willRestore = true;\n              return res.finally(restore);\n            }\n            return res;\n          } finally {\n            if (!willRestore) {\n              restore();\n            }\n          }\n        };\n      });\n      const result = fn.apply(object, finalArgs);\n      if (result && [\"object\", \"function\", \"symbol\"].includes(typeof result)) {\n        this.setState(call.storyId, state => ({\n          callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [result, {\n            __callId__: call.id,\n            retain: call.retain\n          }]])\n        }));\n      }\n      this.update({\n        ...info,\n        status: result instanceof Promise ? \"active\" /* ACTIVE */ : \"done\" /* DONE */\n      });\n      if (result instanceof Promise) {\n        return result.then(value => {\n          this.update({\n            ...info,\n            status: \"done\" /* DONE */\n          });\n          return value;\n        }, handleException);\n      }\n      return result;\n    } catch (e) {\n      return handleException(e);\n    }\n  }\n  // Sends the call info to the manager and synchronizes the log.\n  update(call) {\n    this.channel?.emit(EVENTS.CALL, call);\n    this.setState(call.storyId, ({\n      calls\n    }) => {\n      const callsById = calls.concat(call).reduce((a, c) => Object.assign(a, {\n        [c.id]: c\n      }), {});\n      return {\n        // Calls are sorted to ensure parent calls always come before calls in their callback.\n        calls: Object.values(callsById).sort((a, b) => a.id.localeCompare(b.id, void 0, {\n          numeric: true\n        }))\n      };\n    });\n    this.sync(call.storyId);\n  }\n  // Builds a log of interceptable calls and control states and sends it to the manager.\n  // Uses a 0ms debounce because this might get called many times in one tick.\n  sync(storyId) {\n    const synchronize = /* @__PURE__ */__name(() => {\n      const {\n        isLocked,\n        isPlaying\n      } = this.getState(storyId);\n      const logItems = this.getLog(storyId);\n      const pausedAt = logItems.filter(({\n        ancestors\n      }) => !ancestors.length).find(item => item.status === \"waiting\" /* WAITING */)?.callId;\n      const hasActive = logItems.some(item => item.status === \"active\" /* ACTIVE */);\n      if (this.detached || isLocked || hasActive || logItems.length === 0) {\n        const controlStates2 = {\n          detached: this.detached,\n          start: false,\n          back: false,\n          goto: false,\n          next: false,\n          end: false\n        };\n        const payload2 = {\n          controlStates: controlStates2,\n          logItems\n        };\n        this.channel?.emit(EVENTS.SYNC, payload2);\n        return;\n      }\n      const hasPrevious = logItems.some(item => item.status === \"done\" /* DONE */ || item.status === \"error\" /* ERROR */);\n      const controlStates = {\n        detached: this.detached,\n        start: hasPrevious,\n        back: hasPrevious,\n        goto: true,\n        next: isPlaying,\n        end: isPlaying\n      };\n      const payload = {\n        controlStates,\n        logItems,\n        pausedAt\n      };\n      this.channel?.emit(EVENTS.SYNC, payload);\n    }, \"synchronize\");\n    this.setState(storyId, ({\n      syncTimeout\n    }) => {\n      clearTimeout(syncTimeout);\n      return {\n        syncTimeout: setTimeout(synchronize, 0)\n      };\n    });\n  }\n};\n__name(_Instrumenter, \"Instrumenter\");\nvar Instrumenter = _Instrumenter;\nfunction instrument(obj, options = {}) {\n  try {\n    let forceInstrument = false;\n    let skipInstrument = false;\n    if (global.window?.location?.search?.includes(\"instrument=true\")) {\n      forceInstrument = true;\n    } else if (global.window?.location?.search?.includes(\"instrument=false\")) {\n      skipInstrument = true;\n    }\n    if (global.window?.parent === global.window && !forceInstrument || skipInstrument) {\n      return obj;\n    }\n    if (global.window && !global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__) {\n      global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter();\n    }\n    const instrumenter = global.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__;\n    return instrumenter.instrument(obj, options);\n  } catch (e) {\n    once.warn(e);\n    return obj;\n  }\n}\n__name(instrument, \"instrument\");\nfunction getPropertyDescriptor(obj, propName) {\n  let target = obj;\n  while (target != null) {\n    const descriptor = Object.getOwnPropertyDescriptor(target, propName);\n    if (descriptor) {\n      return descriptor;\n    }\n    target = Object.getPrototypeOf(target);\n  }\n  return void 0;\n}\n__name(getPropertyDescriptor, \"getPropertyDescriptor\");\nfunction isClass(obj) {\n  if (typeof obj !== \"function\") {\n    return false;\n  }\n  const descriptor = Object.getOwnPropertyDescriptor(obj, \"prototype\");\n  if (!descriptor) {\n    return false;\n  }\n  return !descriptor.writable;\n}\n__name(isClass, \"isClass\");\nexport { CallStates, EVENTS, instrument };","map":{"version":3,"names":["CallStates","EVENTS","processError","__name","once","FORCE_REMOUNT","SET_CURRENT_STORY","STORY_RENDER_PHASE_CHANGED","global","addons","globalThis","__STORYBOOK_ADDONS_PREVIEW","alreadyCompletedException","Error","isObject","o","Object","prototype","toString","call","isModule","isInstrumentable","constructor","proto","construct","obj","getInitialState","renderPhase","isDebugging","isPlaying","isLocked","cursor","calls","shadowCalls","callRefsByResult","Map","chainedCallIds","Set","ancestors","playUntil","resolvers","syncTimeout","getRetainedState","state","filter","retain","length","Array","from","entries","ref","_Instrumenter","detached","initialized","loadParentWindowState","window","parent","__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__","updateParentWindowState","resetState","storyId","getState","setState","sync","start","channel","map","status","log","getLog","firstRowIndex","findIndex","id","callId","slice","interceptable","emit","back","last","reduceRight","res","item","index","goto","find","shadowCall","values","nextId","c","forEach","resolve","next","end","renderPhaseChanged","newPhase","ready","then","getChannel","on","cleanup","START","BACK","GOTO","NEXT","END","update","patch","reduce","acc","retainedState","assign","controlStates","payload","logItems","SYNC","merged","seen","args","arg","__callId__","add","path","node","exception","has","unshift","instrument","options","depth","mutate","keys","getKeys","key","descriptor","getPropertyDescriptor","get","configurable","getter","bind","defineProperty","concat","value","__originalFn__","track","writable","method","fn","object","__storyId__","__STORYBOOK_PREVIEW__","selectionStore","selection","intercept","interceptOrInvoke","invoke","result","isChainedUpon","Promise","_","maximumDepth","serializeValues","includes","it","Date","__date__","toISOString","name","message","stack","__error__","RegExp","flags","source","__regexp__","HTMLElement","prefix","localName","classList","innerText","classNames","__element__","__function__","getMockName","__symbol__","description","__class__","fromEntries","val","info","handleException","e","showDiff","diff","actual","expected","hasOwnProperty","actualArgs","getArgs","finalArgs","isClass","restore","willRestore","finally","apply","CALL","callsById","a","sort","b","localeCompare","numeric","synchronize","pausedAt","hasActive","some","controlStates2","payload2","hasPrevious","clearTimeout","setTimeout","Instrumenter","forceInstrument","skipInstrument","location","search","__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__","instrumenter","warn","propName","target","getOwnPropertyDescriptor","getPrototypeOf"],"sources":["/Users/ugurcakil/Documents/projects/ugurk/ng-theme-storybook/node_modules/storybook/dist/instrumenter/index.js"],"sourcesContent":["import {\n  CallStates,\n  EVENTS\n} from \"../_browser-chunks/chunk-SN4J4IQ3.js\";\nimport {\n  processError\n} from \"../_browser-chunks/chunk-JVSKG4YS.js\";\nimport {\n  __name\n} from \"../_browser-chunks/chunk-MM7DTO55.js\";\n\n// src/instrumenter/instrumenter.ts\nimport { once } from \"storybook/internal/client-logger\";\nimport {\n  FORCE_REMOUNT,\n  SET_CURRENT_STORY,\n  STORY_RENDER_PHASE_CHANGED\n} from \"storybook/internal/core-events\";\nimport { global } from \"@storybook/global\";\n\n// src/instrumenter/preview-api.ts\nvar addons = globalThis.__STORYBOOK_ADDONS_PREVIEW;\n\n// src/instrumenter/instrumenter.ts\nvar alreadyCompletedException = new Error(\n  `This function ran after the play function completed. Did you forget to \\`await\\` it?`\n);\nvar isObject = /* @__PURE__ */ __name((o) => Object.prototype.toString.call(o) === \"[object Object]\", \"isObject\");\nvar isModule = /* @__PURE__ */ __name((o) => Object.prototype.toString.call(o) === \"[object Module]\", \"isModule\");\nvar isInstrumentable = /* @__PURE__ */ __name((o) => {\n  if (!isObject(o) && !isModule(o)) {\n    return false;\n  }\n  if (o.constructor === void 0) {\n    return true;\n  }\n  const proto = o.constructor.prototype;\n  if (!isObject(proto)) {\n    return false;\n  }\n  return true;\n}, \"isInstrumentable\");\nvar construct = /* @__PURE__ */ __name((obj) => {\n  try {\n    return new obj.constructor();\n  } catch {\n    return {};\n  }\n}, \"construct\");\nvar getInitialState = /* @__PURE__ */ __name(() => ({\n  renderPhase: \"preparing\",\n  isDebugging: false,\n  isPlaying: false,\n  isLocked: false,\n  cursor: 0,\n  calls: [],\n  shadowCalls: [],\n  callRefsByResult: /* @__PURE__ */ new Map(),\n  chainedCallIds: /* @__PURE__ */ new Set(),\n  ancestors: [],\n  playUntil: void 0,\n  resolvers: {},\n  syncTimeout: void 0\n}), \"getInitialState\");\nvar getRetainedState = /* @__PURE__ */ __name((state, isDebugging = false) => {\n  const calls = (isDebugging ? state.shadowCalls : state.calls).filter((call) => call.retain);\n  if (!calls.length) {\n    return void 0;\n  }\n  const callRefsByResult = new Map(\n    Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain)\n  );\n  return { cursor: calls.length, calls, callRefsByResult };\n}, \"getRetainedState\");\nvar _Instrumenter = class _Instrumenter {\n  constructor() {\n    this.detached = false;\n    this.initialized = false;\n    // State is tracked per story to deal with multiple stories on the same canvas (i.e. docs mode)\n    this.state = {};\n    this.loadParentWindowState = /* @__PURE__ */ __name(() => {\n      try {\n        this.state = global.window?.parent?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};\n      } catch {\n        this.detached = true;\n      }\n    }, \"loadParentWindowState\");\n    this.updateParentWindowState = /* @__PURE__ */ __name(() => {\n      try {\n        global.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n      } catch {\n        this.detached = true;\n      }\n    }, \"updateParentWindowState\");\n    this.loadParentWindowState();\n    const resetState = /* @__PURE__ */ __name(({\n      storyId,\n      renderPhase,\n      isPlaying = true,\n      isDebugging = false\n    }) => {\n      const state = this.getState(storyId);\n      this.setState(storyId, {\n        ...getInitialState(),\n        ...getRetainedState(state, isDebugging),\n        renderPhase: renderPhase || state.renderPhase,\n        shadowCalls: isDebugging ? state.shadowCalls : [],\n        chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */ new Set(),\n        playUntil: isDebugging ? state.playUntil : void 0,\n        isPlaying,\n        isDebugging\n      });\n      this.sync(storyId);\n    }, \"resetState\");\n    const start = /* @__PURE__ */ __name((channel) => ({ storyId, playUntil }) => {\n      if (!this.getState(storyId).isDebugging) {\n        this.setState(storyId, ({ calls }) => ({\n          calls: [],\n          shadowCalls: calls.map((call) => ({ ...call, status: \"waiting\" /* WAITING */ })),\n          isDebugging: true\n        }));\n      }\n      const log = this.getLog(storyId);\n      this.setState(storyId, ({ shadowCalls }) => {\n        if (playUntil || !log.length) {\n          return { playUntil };\n        }\n        const firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);\n        return {\n          playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors?.length).slice(-1)[0]?.id\n        };\n      });\n      channel.emit(FORCE_REMOUNT, { storyId, isDebugging: true });\n    }, \"start\");\n    const back = /* @__PURE__ */ __name((channel) => ({ storyId }) => {\n      const log = this.getLog(storyId).filter((call) => !call.ancestors?.length);\n      const last = log.reduceRight((res, item, index) => {\n        if (res >= 0 || item.status === \"waiting\" /* WAITING */) {\n          return res;\n        }\n        return index;\n      }, -1);\n      start(channel)({ storyId, playUntil: log[last - 1]?.callId });\n    }, \"back\");\n    const goto = /* @__PURE__ */ __name((channel) => ({ storyId, callId }) => {\n      const { calls, shadowCalls, resolvers } = this.getState(storyId);\n      const call = calls.find(({ id }) => id === callId);\n      const shadowCall = shadowCalls.find(({ id }) => id === callId);\n      if (!call && shadowCall && Object.values(resolvers).length > 0) {\n        const nextId = this.getLog(storyId).find((c) => c.status === \"waiting\" /* WAITING */)?.callId;\n        if (shadowCall.id !== nextId) {\n          this.setState(storyId, { playUntil: shadowCall.id });\n        }\n        Object.values(resolvers).forEach((resolve) => resolve());\n      } else {\n        start(channel)({ storyId, playUntil: callId });\n      }\n    }, \"goto\");\n    const next = /* @__PURE__ */ __name((channel) => ({ storyId }) => {\n      const { resolvers } = this.getState(storyId);\n      if (Object.values(resolvers).length > 0) {\n        Object.values(resolvers).forEach((resolve) => resolve());\n      } else {\n        const nextId = this.getLog(storyId).find((c) => c.status === \"waiting\" /* WAITING */)?.callId;\n        if (nextId) {\n          start(channel)({ storyId, playUntil: nextId });\n        } else {\n          end({ storyId });\n        }\n      }\n    }, \"next\");\n    const end = /* @__PURE__ */ __name(({ storyId }) => {\n      this.setState(storyId, { playUntil: void 0, isDebugging: false });\n      Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());\n    }, \"end\");\n    const renderPhaseChanged = /* @__PURE__ */ __name(({\n      storyId,\n      newPhase\n    }) => {\n      const { isDebugging } = this.getState(storyId);\n      if (newPhase === \"preparing\" && isDebugging) {\n        return resetState({ storyId, renderPhase: newPhase, isDebugging });\n      } else if (newPhase === \"playing\") {\n        return resetState({ storyId, renderPhase: newPhase, isDebugging });\n      }\n      if (newPhase === \"played\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: false,\n          isPlaying: false,\n          isDebugging: false\n        });\n      } else if (newPhase === \"errored\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: false,\n          isPlaying: false\n        });\n      } else if (newPhase === \"aborted\") {\n        this.setState(storyId, {\n          renderPhase: newPhase,\n          isLocked: true,\n          isPlaying: false\n        });\n      } else {\n        this.setState(storyId, {\n          renderPhase: newPhase\n        });\n      }\n      this.sync(storyId);\n    }, \"renderPhaseChanged\");\n    if (addons) {\n      addons.ready().then(() => {\n        this.channel = addons.getChannel();\n        this.channel.on(FORCE_REMOUNT, resetState);\n        this.channel.on(STORY_RENDER_PHASE_CHANGED, renderPhaseChanged);\n        this.channel.on(SET_CURRENT_STORY, () => {\n          if (this.initialized) {\n            this.cleanup();\n          } else {\n            this.initialized = true;\n          }\n        });\n        this.channel.on(EVENTS.START, start(this.channel));\n        this.channel.on(EVENTS.BACK, back(this.channel));\n        this.channel.on(EVENTS.GOTO, goto(this.channel));\n        this.channel.on(EVENTS.NEXT, next(this.channel));\n        this.channel.on(EVENTS.END, end);\n      });\n    }\n  }\n  getState(storyId) {\n    return this.state[storyId] || getInitialState();\n  }\n  setState(storyId, update) {\n    if (storyId) {\n      const state = this.getState(storyId);\n      const patch = typeof update === \"function\" ? update(state) : update;\n      this.state = { ...this.state, [storyId]: { ...state, ...patch } };\n      this.updateParentWindowState();\n    }\n  }\n  cleanup() {\n    this.state = Object.entries(this.state).reduce(\n      (acc, [storyId, state]) => {\n        const retainedState = getRetainedState(state);\n        if (!retainedState) {\n          return acc;\n        }\n        acc[storyId] = Object.assign(getInitialState(), retainedState);\n        return acc;\n      },\n      {}\n    );\n    const controlStates = {\n      detached: this.detached,\n      start: false,\n      back: false,\n      goto: false,\n      next: false,\n      end: false\n    };\n    const payload = { controlStates, logItems: [] };\n    this.channel?.emit(EVENTS.SYNC, payload);\n    this.updateParentWindowState();\n  }\n  getLog(storyId) {\n    const { calls, shadowCalls } = this.getState(storyId);\n    const merged = [...shadowCalls];\n    calls.forEach((call, index) => {\n      merged[index] = call;\n    });\n    const seen = /* @__PURE__ */ new Set();\n    return merged.reduceRight((acc, call) => {\n      call.args.forEach((arg) => {\n        if (arg?.__callId__) {\n          seen.add(arg.__callId__);\n        }\n      });\n      call.path.forEach((node) => {\n        if (node.__callId__) {\n          seen.add(node.__callId__);\n        }\n      });\n      if ((call.interceptable || call.exception) && !seen.has(call.id)) {\n        acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors });\n        seen.add(call.id);\n      }\n      return acc;\n    }, []);\n  }\n  // Traverses the object structure to recursively patch all function properties.\n  // Returns the original object, or a new object with the same constructor,\n  // depending on whether it should mutate.\n  instrument(obj, options, depth = 0) {\n    if (!isInstrumentable(obj)) {\n      return obj;\n    }\n    const { mutate = false, path = [] } = options;\n    const keys = options.getKeys ? options.getKeys(obj, depth) : Object.keys(obj);\n    depth += 1;\n    return keys.reduce(\n      (acc, key) => {\n        const descriptor = getPropertyDescriptor(obj, key);\n        if (typeof descriptor?.get === \"function\") {\n          if (descriptor.configurable) {\n            const getter = /* @__PURE__ */ __name(() => descriptor?.get?.bind(obj)?.(), \"getter\");\n            Object.defineProperty(acc, key, {\n              get: /* @__PURE__ */ __name(() => {\n                return this.instrument(getter(), { ...options, path: path.concat(key) }, depth);\n              }, \"get\")\n            });\n          }\n          return acc;\n        }\n        const value = obj[key];\n        if (typeof value !== \"function\") {\n          acc[key] = this.instrument(value, { ...options, path: path.concat(key) }, depth);\n          return acc;\n        }\n        if (\"__originalFn__\" in value && typeof value.__originalFn__ === \"function\") {\n          acc[key] = value;\n          return acc;\n        }\n        acc[key] = (...args) => this.track(key, value, obj, args, options);\n        acc[key].__originalFn__ = value;\n        Object.defineProperty(acc[key], \"name\", { value: key, writable: false });\n        if (Object.keys(value).length > 0) {\n          Object.assign(\n            acc[key],\n            this.instrument({ ...value }, { ...options, path: path.concat(key) }, depth)\n          );\n        }\n        return acc;\n      },\n      mutate ? obj : construct(obj)\n    );\n  }\n  // Monkey patch an object method to record calls.\n  // Returns a function that invokes the original function, records the invocation (\"call\") and\n  // returns the original result.\n  track(method, fn, object, args, options) {\n    const storyId = args?.[0]?.__storyId__ || global.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId;\n    const { cursor, ancestors } = this.getState(storyId);\n    this.setState(storyId, { cursor: cursor + 1 });\n    const id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`;\n    const { path = [], intercept = false, retain = false } = options;\n    const interceptable = typeof intercept === \"function\" ? intercept(method, path) : intercept;\n    const call = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain };\n    const interceptOrInvoke = interceptable && !ancestors.length ? this.intercept : this.invoke;\n    const result = interceptOrInvoke.call(this, fn, object, call, options);\n    return this.instrument(result, { ...options, mutate: true, path: [{ __callId__: call.id }] });\n  }\n  intercept(fn, object, call, options) {\n    const { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId);\n    const isChainedUpon = chainedCallIds.has(call.id);\n    if (!isDebugging || isChainedUpon || playUntil) {\n      if (playUntil === call.id) {\n        this.setState(call.storyId, { playUntil: void 0 });\n      }\n      return this.invoke(fn, object, call, options);\n    }\n    return new Promise((resolve) => {\n      this.setState(call.storyId, ({ resolvers }) => ({\n        isLocked: false,\n        resolvers: { ...resolvers, [call.id]: resolve }\n      }));\n    }).then(() => {\n      this.setState(call.storyId, (state) => {\n        const { [call.id]: _, ...resolvers } = state.resolvers;\n        return { isLocked: true, resolvers };\n      });\n      return this.invoke(fn, object, call, options);\n    });\n  }\n  invoke(fn, object, call, options) {\n    const { callRefsByResult, renderPhase } = this.getState(call.storyId);\n    const maximumDepth = 25;\n    const serializeValues = /* @__PURE__ */ __name((value, depth, seen) => {\n      if (seen.includes(value)) {\n        return \"[Circular]\";\n      }\n      seen = [...seen, value];\n      if (depth > maximumDepth) {\n        return \"...\";\n      }\n      if (callRefsByResult.has(value)) {\n        return callRefsByResult.get(value);\n      }\n      if (value instanceof Array) {\n        return value.map((it) => serializeValues(it, ++depth, seen));\n      }\n      if (value instanceof Date) {\n        return { __date__: { value: value.toISOString() } };\n      }\n      if (value instanceof Error) {\n        const { name, message, stack } = value;\n        return { __error__: { name, message, stack } };\n      }\n      if (value instanceof RegExp) {\n        const { flags, source } = value;\n        return { __regexp__: { flags, source } };\n      }\n      if (value instanceof global.window?.HTMLElement) {\n        const { prefix, localName, id, classList, innerText } = value;\n        const classNames = Array.from(classList);\n        return { __element__: { prefix, localName, id, classNames, innerText } };\n      }\n      if (typeof value === \"function\") {\n        return {\n          __function__: { name: \"getMockName\" in value ? value.getMockName() : value.name }\n        };\n      }\n      if (typeof value === \"symbol\") {\n        return { __symbol__: { description: value.description } };\n      }\n      if (typeof value === \"object\" && value?.constructor?.name && value?.constructor?.name !== \"Object\") {\n        return { __class__: { name: value.constructor.name } };\n      }\n      if (Object.prototype.toString.call(value) === \"[object Object]\") {\n        return Object.fromEntries(\n          Object.entries(value).map(([key, val]) => [key, serializeValues(val, ++depth, seen)])\n        );\n      }\n      return value;\n    }, \"serializeValues\");\n    const info = {\n      ...call,\n      args: call.args.map((arg) => serializeValues(arg, 0, []))\n    };\n    call.path.forEach((ref) => {\n      if (ref?.__callId__) {\n        this.setState(call.storyId, ({ chainedCallIds }) => ({\n          chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__))\n        }));\n      }\n    });\n    const handleException = /* @__PURE__ */ __name((e) => {\n      if (e instanceof Error) {\n        const { name, message, stack, callId = call.id } = e;\n        const {\n          showDiff = void 0,\n          diff = void 0,\n          actual = void 0,\n          expected = void 0\n        } = e.name === \"AssertionError\" ? processError(e) : e;\n        const exception = { name, message, stack, callId, showDiff, diff, actual, expected };\n        this.update({ ...info, status: \"error\" /* ERROR */, exception });\n        this.setState(call.storyId, (state) => ({\n          callRefsByResult: new Map([\n            ...Array.from(state.callRefsByResult.entries()),\n            [e, { __callId__: call.id, retain: call.retain }]\n          ])\n        }));\n        if (call.ancestors?.length) {\n          if (!Object.prototype.hasOwnProperty.call(e, \"callId\")) {\n            Object.defineProperty(e, \"callId\", { value: call.id });\n          }\n          throw e;\n        }\n      }\n      throw e;\n    }, \"handleException\");\n    try {\n      if (renderPhase === \"played\" && !call.retain) {\n        throw alreadyCompletedException;\n      }\n      const actualArgs = options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args;\n      const finalArgs = actualArgs.map((arg) => {\n        if (typeof arg !== \"function\" || isClass(arg) || Object.keys(arg).length) {\n          return arg;\n        }\n        return (...args) => {\n          const { cursor, ancestors } = this.getState(call.storyId);\n          this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });\n          const restore = /* @__PURE__ */ __name(() => this.setState(call.storyId, { cursor, ancestors }), \"restore\");\n          let willRestore = false;\n          try {\n            const res = arg(...args);\n            if (res instanceof Promise) {\n              willRestore = true;\n              return res.finally(restore);\n            }\n            return res;\n          } finally {\n            if (!willRestore) {\n              restore();\n            }\n          }\n        };\n      });\n      const result = fn.apply(object, finalArgs);\n      if (result && [\"object\", \"function\", \"symbol\"].includes(typeof result)) {\n        this.setState(call.storyId, (state) => ({\n          callRefsByResult: new Map([\n            ...Array.from(state.callRefsByResult.entries()),\n            [result, { __callId__: call.id, retain: call.retain }]\n          ])\n        }));\n      }\n      this.update({\n        ...info,\n        status: result instanceof Promise ? \"active\" /* ACTIVE */ : \"done\" /* DONE */\n      });\n      if (result instanceof Promise) {\n        return result.then((value) => {\n          this.update({ ...info, status: \"done\" /* DONE */ });\n          return value;\n        }, handleException);\n      }\n      return result;\n    } catch (e) {\n      return handleException(e);\n    }\n  }\n  // Sends the call info to the manager and synchronizes the log.\n  update(call) {\n    this.channel?.emit(EVENTS.CALL, call);\n    this.setState(call.storyId, ({ calls }) => {\n      const callsById = calls.concat(call).reduce((a, c) => Object.assign(a, { [c.id]: c }), {});\n      return {\n        // Calls are sorted to ensure parent calls always come before calls in their callback.\n        calls: Object.values(callsById).sort(\n          (a, b) => a.id.localeCompare(b.id, void 0, { numeric: true })\n        )\n      };\n    });\n    this.sync(call.storyId);\n  }\n  // Builds a log of interceptable calls and control states and sends it to the manager.\n  // Uses a 0ms debounce because this might get called many times in one tick.\n  sync(storyId) {\n    const synchronize = /* @__PURE__ */ __name(() => {\n      const { isLocked, isPlaying } = this.getState(storyId);\n      const logItems = this.getLog(storyId);\n      const pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === \"waiting\" /* WAITING */)?.callId;\n      const hasActive = logItems.some((item) => item.status === \"active\" /* ACTIVE */);\n      if (this.detached || isLocked || hasActive || logItems.length === 0) {\n        const controlStates2 = {\n          detached: this.detached,\n          start: false,\n          back: false,\n          goto: false,\n          next: false,\n          end: false\n        };\n        const payload2 = { controlStates: controlStates2, logItems };\n        this.channel?.emit(EVENTS.SYNC, payload2);\n        return;\n      }\n      const hasPrevious = logItems.some(\n        (item) => item.status === \"done\" /* DONE */ || item.status === \"error\" /* ERROR */\n      );\n      const controlStates = {\n        detached: this.detached,\n        start: hasPrevious,\n        back: hasPrevious,\n        goto: true,\n        next: isPlaying,\n        end: isPlaying\n      };\n      const payload = { controlStates, logItems, pausedAt };\n      this.channel?.emit(EVENTS.SYNC, payload);\n    }, \"synchronize\");\n    this.setState(storyId, ({ syncTimeout }) => {\n      clearTimeout(syncTimeout);\n      return { syncTimeout: setTimeout(synchronize, 0) };\n    });\n  }\n};\n__name(_Instrumenter, \"Instrumenter\");\nvar Instrumenter = _Instrumenter;\nfunction instrument(obj, options = {}) {\n  try {\n    let forceInstrument = false;\n    let skipInstrument = false;\n    if (global.window?.location?.search?.includes(\"instrument=true\")) {\n      forceInstrument = true;\n    } else if (global.window?.location?.search?.includes(\"instrument=false\")) {\n      skipInstrument = true;\n    }\n    if (global.window?.parent === global.window && !forceInstrument || skipInstrument) {\n      return obj;\n    }\n    if (global.window && !global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__) {\n      global.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter();\n    }\n    const instrumenter = global.window?.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__;\n    return instrumenter.instrument(obj, options);\n  } catch (e) {\n    once.warn(e);\n    return obj;\n  }\n}\n__name(instrument, \"instrument\");\nfunction getPropertyDescriptor(obj, propName) {\n  let target = obj;\n  while (target != null) {\n    const descriptor = Object.getOwnPropertyDescriptor(target, propName);\n    if (descriptor) {\n      return descriptor;\n    }\n    target = Object.getPrototypeOf(target);\n  }\n  return void 0;\n}\n__name(getPropertyDescriptor, \"getPropertyDescriptor\");\nfunction isClass(obj) {\n  if (typeof obj !== \"function\") {\n    return false;\n  }\n  const descriptor = Object.getOwnPropertyDescriptor(obj, \"prototype\");\n  if (!descriptor) {\n    return false;\n  }\n  return !descriptor.writable;\n}\n__name(isClass, \"isClass\");\nexport {\n  CallStates,\n  EVENTS,\n  instrument\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}